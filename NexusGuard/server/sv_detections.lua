--[[
    NexusGuard Enhanced Detection System (server/modules/detections.lua)

    Purpose:
    - Central logic for processing detection reports received from clients or generated by server-side checks
    - Validates the received data against server-side logic and configuration thresholds
    - Determines the severity of the detection with context-aware analysis
    - Applies penalties based on severity and trust score, including logging, trust score reduction,
      Discord notifications, and potentially kicks or bans
    - Provides advanced detection capabilities with pattern recognition and behavioral analysis

    Key Features:
    - Context-aware validation that considers player state and game mechanics
    - Severity calculation based on multiple factors (not just detection type)
    - Automatic response system that scales based on detection severity and history
    - Integration with existing ban/kick system
    - Advanced pattern recognition for detecting sophisticated cheats

    Dependencies:
    - Injected Config and Core references (for Utils, Bans, Discord)
    - `ox_lib` resource (for `lib.json`)

    Usage:
    - Initialized via `Core.LoadModules` and exposed through the server API
    - The `Process` function is the main entry point, called by event handlers in `server_main.lua`
      or potentially other server-side checks
]]
local Detections = {
    -- Store detection history for pattern analysis
    history = {},

    -- Store player behavior patterns
    patterns = {},

    -- Detection confidence levels
    confidenceLevels = {
        NONE = 0,       -- No confidence (0%)
        VERY_LOW = 0.2, -- Very low confidence (20%)
        LOW = 0.4,      -- Low confidence (40%)
        MEDIUM = 0.6,   -- Medium confidence (60%)
        HIGH = 0.8,     -- High confidence (80%)
        CERTAIN = 1.0   -- Certain (100%)
    },

    -- Detection confidence descriptions
    confidenceDescriptions = {
        [0] = "None",       -- No confidence (0%)
        [0.2] = "Very Low", -- Very low confidence (20%)
        [0.4] = "Low",      -- Low confidence (40%)
        [0.6] = "Medium",   -- Medium confidence (60%)
        [0.8] = "High",     -- High confidence (80%)
        [1.0] = "Certain"   -- Certain (100%)
    },
    -- Detection severity levels
    severityLevels = {
        INFO = "Info",         -- Informational, no action needed
        LOW = "Low",           -- Low severity, monitor only
        MEDIUM = "Medium",     -- Medium severity, potential issue
        HIGH = "High",         -- High severity, likely cheating
        CRITICAL = "Critical"  -- Critical severity, definite cheating
    },

    -- Default thresholds for various detection types
    defaultThresholds = {
        -- Time window for pattern analysis (in seconds)
        patternTimeWindow = 300,  -- 5 minutes

        -- Number of similar detections to trigger pattern recognition
        patternDetectionThreshold = 3,

        -- Maximum history size per player
        maxHistorySize = 50,

        -- Cleanup interval (in milliseconds)
        cleanupInterval = 300000,  -- 5 minutes

        -- Last cleanup timestamp
        lastCleanup = 0
    }
}

-- Load required modules
local Natives = require('shared/natives')                 -- Load the natives wrapper
local Dependencies = require('shared/dependency_manager') -- Load the dependency manager
local ModuleLoader = require('shared/module_loader')      -- Load the module loader

local Config, Log, Core

function Detections.Initialize(cfg, logFunc, core)
    Config = cfg or {}
    Log = logFunc or function(...) print('[Detections]', ...) end
    Core = core
    Dependencies.Initialize(Log)
end

--[[
    Validates the basic structure of incoming detection data.
    Ensures it's a table and contains expected (even if nil) fields.

    @param detectionData (any): The raw data received with the detection report.
    @return (table): A validated table structure, potentially wrapping non-table input.
]]
local function ValidateDetectionData(detectionData)
    if type(detectionData) ~= "table" then
        Log(("^1Detections Validation Warning: Received non-table detection data (%s). Wrapping it.^7"):format(type(detectionData)), 1)
        -- Wrap non-table data for consistency, assume client validation failed.
        return { value = detectionData, details = {}, clientValidated = false }
    end
    -- Ensure essential fields exist, defaulting if necessary.
    detectionData.value = detectionData.value -- The primary value reported (e.g., speed, health).
    detectionData.details = detectionData.details or {} -- Additional contextual details.
    detectionData.clientValidated = detectionData.clientValidated or false -- Flag indicating if the client-side detector triggered this report.
    return detectionData
end

--[[
    Applies penalties based on a validated detection.
    - Logs the detection event.
    - Reduces the player's trust score based on severity.
    - Stores the detection event in the player's session metrics.
    - Sends a Discord notification (if configured).
    - Executes kick/ban actions based on trust score thresholds defined in config.

    @param playerId (number): The server ID of the player.
    @param session (table): The player's session data object.
    @param detectionType (string): The type of detection.
    @param validatedData (table): The validated detection data, including server-side validation results/reason.
    @param severity (string): The determined severity ("Low", "Medium", "High", "Critical", "Info").
]]
local function ApplyPenalty(playerId, session, detectionType, validatedData, severity)
    local playerName = Natives.GetPlayerName(playerId) or ("Unknown (" .. tostring(playerId) .. ")")
    local reason = validatedData.reason or "No specific reason provided."
    local details = validatedData.details or {}
    -- Determine trust score impact based on severity config, with defaults.
    local trustImpact = (Config.Severity and Config.Severity[detectionType]) or
                        (Config.Severity and Config.Severity.default) or 5

    -- Ensure JSON encoding is safe for logging details.
    local detailsJson = "error encoding"
    local encSuccess, encResult = pcall(function()
        return Dependencies.JSON.encode(details)
    end)
    if encSuccess and encResult then
        detailsJson = encResult
    end

    -- Log the confirmed detection event.
    Log(("^1[NexusGuard Detection Confirmed]^7 Player: %s (ID: %d) | Type: %s | Severity: %s | Reason: %s | Details: %s^7"):format(
        playerName, playerId, detectionType, severity, reason, detailsJson
    ), 1)

    -- Update Trust Score in session metrics.
    if session and session.metrics then
        local oldTrust = session.metrics.trustScore or 100
        session.metrics.trustScore = math.max(0, oldTrust - trustImpact) -- Clamp score at 0.
        Log(("^3[NexusGuard Trust]^7 Trust score for %s (ID: %d) reduced by %d due to %s. New score: %.1f^7"):format(
            playerName, playerId, trustImpact, detectionType, session.metrics.trustScore
        ), 2)

        -- Store the detection event details within the session metrics.
        if not session.metrics.detections then session.metrics.detections = {} end
        table.insert(session.metrics.detections, {
            type = detectionType,
            reason = reason,
            details = details, -- Store original table, not JSON
            severity = severity,
            trustImpact = trustImpact,
            timestamp = os.time()
        })
        -- Also store in database if configured
        if Detections.Store then
            Detections.Store(playerId, detectionType, validatedData)
        end
    else
         Log(("^1Detections Penalty Warning: Cannot apply trust score penalty or store detection for %s (ID: %d) - session or metrics missing.^7"):format(playerName, playerId), 1)
    end

    -- Send Discord Notification via Discord module API.
    local Discord = Core and Core.GetModule and Core.GetModule('Discord')
    if Discord and Discord.Send then
        local embedData = {
            { name = "Player", value = string.format("%s (`%d`)", playerName, playerId), inline = true },
            { name = "Detection", value = detectionType, inline = true },
            { name = "Severity", value = severity, inline = true },
            { name = "Reason", value = reason, inline = false },
            { name = "Details", value = string.format("```json\n%s\n```", detailsJson), inline = false },
            { name = "Trust Score", value = string.format("%.1f (`-%d`)", session and session.metrics and session.metrics.trustScore or -1.0, trustImpact), inline = true }
        }
        local webhook = Config.Discord and Config.Discord.webhooks and Config.Discord.webhooks.detections
        Discord.Send("detections", "Suspicious Activity Detected", embedData, webhook)
    end

    -- Execute Actions (Ban/Kick) based on trust score thresholds defined in config.
    -- TODO: Implement more sophisticated progressive banning logic (e.g., based on frequency/severity of recent detections).
    local actionConfig = (Config.Actions and Config.Actions[detectionType]) or
                         (Config.Actions and Config.Actions.default) or
                         { kickThreshold = 50, banThreshold = 20 } -- Default thresholds if not configured.
    local currentTrust = (session and session.metrics and session.metrics.trustScore) or 100.0 -- Default to 100 if unavailable.

    -- Check Ban Threshold
    if currentTrust <= actionConfig.banThreshold then
        Log(("^1[NexusGuard Action]^7 Trust score (%.1f) reached ban threshold (<= %.1f) for detection '%s'. Banning %s (ID: %d).^7"):format(
            currentTrust, actionConfig.banThreshold, detectionType, playerName, playerId
        ), 1)
        -- Execute ban via Bans module API.
        local Bans = Core and Core.GetModule and Core.GetModule('Bans')
        if Bans and Bans.Execute then
            local banReason = ("Automatic ban: Triggered %s (Trust Score: %.1f)"):format(detectionType, currentTrust)
            Bans.Execute(playerId, banReason, "NexusGuard System") -- Default to permanent ban.
        else
             Log("^1Detections Action Error: Bans.Execute function missing from API. Cannot ban player. Kicking as fallback.^7", 1)
            Natives.DropPlayer(playerId, "Kicked by Anti-Cheat (System Error: Ban Function Missing)")
        end
    -- Check Kick Threshold (only if not banned)
    elseif currentTrust <= actionConfig.kickThreshold then
        Log(("^1[NexusGuard Action]^7 Trust score (%.1f) reached kick threshold (<= %.1f) for detection '%s'. Kicking %s (ID: %d).^7"):format(
            currentTrust, actionConfig.kickThreshold, detectionType, playerName, playerId
        ), 1)
        local kickReason = ("Kicked by Anti-Cheat: Triggered %s (Trust Score: %.1f)"):format(detectionType, currentTrust)
        Natives.DropPlayer(playerId, kickReason)
    end
end

--[[
    Main processing function for detection reports.
    Validates incoming data, performs server-side checks, determines severity, and applies penalties.

    @param playerId (number): The server ID of the player associated with the detection.
    @param detectionType (string): A string identifying the type of detection (e.g., "SpeedHack", "GodMode", "ServerSpeedCheck").
    @param detectionData (table): A table containing details reported by the client detector or server-side check.
                                  Expected fields vary by detection type but often include `value`, `details`, `clientValidated`.
    @param session (table): The player's session data object, containing metrics and state.
    @return (boolean): True if the detection was validated server-side, false otherwise.
]]
function Detections.Process(playerId, detectionType, detectionData, session)
    -- Ensure essential components are loaded.
    if not Config or not Log then print("^1[NexusGuard Detections] CRITICAL: Config or Log function not available. Cannot process detection.^7"); return false end

    local playerName = Natives.GetPlayerName(playerId) or ("Unknown (" .. tostring(playerId) .. ")")
    Log(("^3Detections: Processing report for player %s (ID: %d), Type: %s^7"):format(playerName, playerId, detectionType), 3)

    -- 1. Validate Input Data Structure: Ensure detectionData is a table with expected base fields.
    local validatedData = ValidateDetectionData(detectionData)
    validatedData.serverValidated = false -- Initialize server validation status for this run.
    validatedData.reason = validatedData.reason or "Initial report received" -- Default reason if none provided.

    -- 2. Perform Server-Side Validation: Check the data against server logic and config.
    local isValid = false          -- Flag indicating if server-side checks confirm the detection.
    local severity = "Low"         -- Default severity, adjusted based on validation.

    -- Ensure session and metrics are available, as they are crucial for most validations.
    if not session or not session.metrics then
        Log(("^1Detections Validation Error: Cannot validate detection '%s' for %s (ID: %d) - Session or metrics data missing.^7"):format(detectionType, playerName, playerId), 1)
        -- Cannot proceed with validation without session data.
        return false
    end

    -- Access config tables for convenience.
    local cfg = Config
    local Thresholds = cfg.Thresholds or {}
    local Features = cfg.Features or {}

    -- --- Specific Detection Type Validation Logic ---
    -- Use 'elseif' structure to handle different detection types.

    -- Speed Hack / Server Speed Check Validation
    if detectionType == "SpeedHack" or detectionType == "ServerSpeedCheck" then
        -- Extract speed value (might come from client 'value' or server 'calculatedSpeed').
        local speed = tonumber(validatedData.value) or tonumber(validatedData.calculatedSpeed) or tonumber(validatedData.details and validatedData.details.speed)
        if speed then
            local baseThreshold = Thresholds.serverSideSpeedThreshold or 50.0 -- Base speed limit (m/s).
            local effectiveThreshold = baseThreshold
            local reasonSuffix = ""
            local confidenceLevel = Detections.confidenceLevels.HIGH -- Default confidence

            -- Enhanced context-aware validation (Guideline 26, 38)
            -- Check for recent teleport or spawn events
            if session.metrics.justTeleported or session.metrics.justSpawned then
                -- Skip validation during teleport/spawn grace periods
                isValid = false
                validatedData.reason = "Speed check skipped during teleport/spawn grace period"
                severity = "Info"
                validatedData.serverValidated = false
                return false
            end

            -- Adjust threshold based on player state with more granular context awareness
            if session.metrics.isFalling or session.metrics.isRagdoll or session.metrics.isInParachute then
                -- Falling/ragdoll/parachute states can legitimately cause high speeds
                effectiveThreshold = baseThreshold * 2.5
                reasonSuffix = " (Adjusted for falling/ragdoll/parachute)"
                confidenceLevel = Detections.confidenceLevels
                    .MEDIUM -- Lower confidence due to potential false positives
            elseif session.metrics.verticalVelocity and session.metrics.verticalVelocity < -10.0 then
                -- Significant downward velocity (falling without the flag set)
                effectiveThreshold = baseThreshold * 2.0
                reasonSuffix = " (Adjusted for vertical velocity)"
                confidenceLevel = Detections.confidenceLevels.MEDIUM
            elseif session.metrics.isInVehicle then
                -- Vehicle type-based threshold adjustment
                local vehicleClass = -1
                local vehicleEntity = session.metrics.currentVehicle

                if vehicleEntity and Natives.DoesEntityExist(vehicleEntity) then
                    vehicleClass = Natives.GetVehicleClass(vehicleEntity)
                end

                -- Adjust threshold based on vehicle class
                if vehicleClass == 16 then -- Planes
                    effectiveThreshold = baseThreshold * 3.0
                    reasonSuffix = " (Adjusted for aircraft)"
                elseif vehicleClass == 15 then -- Helicopters
                    effectiveThreshold = baseThreshold * 2.0
                    reasonSuffix = " (Adjusted for helicopter)"
                elseif vehicleClass == 14 then -- Boats
                    effectiveThreshold = baseThreshold * 1.5
                    reasonSuffix = " (Adjusted for boat)"
                elseif vehicleClass == 8 then -- Motorcycles
                    effectiveThreshold = baseThreshold * 1.4
                    reasonSuffix = " (Adjusted for motorcycle)"
                else -- Other vehicles
                    effectiveThreshold = baseThreshold * 1.3
                    reasonSuffix = " (Adjusted for vehicle)"
                end
            end

            -- Check for recent damage events that might cause speed spikes
            if session.metrics.recentDamage and (os.time() - session.metrics.recentDamage.timestamp) < 3 then
                effectiveThreshold = effectiveThreshold * 1.2 -- Allow higher speed after taking damage
                reasonSuffix = reasonSuffix .. " (Adjusted for recent damage)"
                confidenceLevel = Detections.confidenceLevels.MEDIUM
            end

            -- Check if calculated speed exceeds the adjusted threshold.
            if speed > effectiveThreshold then
                -- Additional validation: Check for consistent speed violations
                local consistentViolation = false

                -- If we have previous speed samples, check for a pattern of violations
                if session.metrics.speedSamples and #session.metrics.speedSamples >= 2 then
                    local violationCount = 0
                    for _, sample in ipairs(session.metrics.speedSamples) do
                        if sample.speed > sample.threshold then
                            violationCount = violationCount + 1
                        end
                    end

                    -- If more than 50% of recent samples violated thresholds, consider it consistent
                    consistentViolation = (violationCount / #session.metrics.speedSamples) > 0.5

                    if consistentViolation then
                        confidenceLevel = Detections.confidenceLevels.CERTAIN
                    else
                        confidenceLevel = Detections.confidenceLevels.MEDIUM
                    end
                end

                -- Store the current speed sample for future pattern analysis
                if not session.metrics.speedSamples then
                    session.metrics.speedSamples = {}
                end

                -- Keep only the last 5 samples
                if #session.metrics.speedSamples >= 5 then
                    table.remove(session.metrics.speedSamples, 1)
                end

                table.insert(session.metrics.speedSamples, {
                    speed = speed,
                    threshold = effectiveThreshold,
                    timestamp = os.time(),
                    violation = speed > effectiveThreshold
                })

                -- Determine severity based on how much the threshold was exceeded and confidence level
                local thresholdExceedFactor = speed / effectiveThreshold

                if thresholdExceedFactor > 2.0 and confidenceLevel >= Detections.confidenceLevels.HIGH then
                    severity = "Critical" -- Extreme speed, high confidence
                elseif thresholdExceedFactor > 1.5 or consistentViolation then
                    severity = "High"     -- Significant speed or consistent violations
                elseif thresholdExceedFactor > 1.2 then
                    severity = "Medium"   -- Moderate speed violation
                else
                    severity = "Low"      -- Minor speed violation
                end
                isValid = true
                validatedData.reason = string.format(
                    "Calculated speed %.2f m/s exceeded threshold %.2f m/s%s (%.1fx, Confidence: %.1f)",
                    speed, effectiveThreshold, reasonSuffix, thresholdExceedFactor, confidenceLevel)
                -- Store relevant details for logging/review.
                validatedData.details.speed = speed
                validatedData.details.threshold = effectiveThreshold
                validatedData.details.exceedFactor = thresholdExceedFactor
                validatedData.details.confidence = confidenceLevel
                validatedData.details.consistent = consistentViolation
                validatedData.details.state = {
                    falling = session.metrics.isFalling,
                    ragdoll = session.metrics.isRagdoll,
                    parachute = session.metrics.isInParachute,
                    inVehicle = session.metrics.isInVehicle,
                    vertVel = session.metrics.verticalVelocity,
                    vehicleClass = vehicleClass or -1
                }
            end
        else
            -- If speed value is missing or invalid.
            validatedData.reason = "Invalid or missing speed value in detection data."
            severity = "Info" -- Treat as informational, not a confirmed cheat.
        end
        validatedData.serverValidated = isValid -- Update server validation status.

    -- God Mode / Health Regeneration Check Validation
    elseif detectionType == "GodMode" or detectionType == "ServerHealthRegenCheck" then
        -- Extract data specific to the server-side health regen check.
        local increase = tonumber(validatedData.increase)
        local rate = tonumber(validatedData.rate)
        local regenThreshold = Thresholds.serverSideRegenThreshold or 3.0 -- Max allowed HP/sec regen.
        local confidenceLevel = Detections.confidenceLevels.MEDIUM        -- Default confidence

        -- Skip validation during spawn grace period
        if session.metrics.justSpawned then
            isValid = false
            validatedData.reason = "Health check skipped during spawn grace period"
            severity = "Info"
            validatedData.serverValidated = false
            return false
        end

        -- Check for recent healing events that might explain health increase
        local hasRecentHealing = false
        if session.metrics.healingEvents then
            for _, event in ipairs(session.metrics.healingEvents) do
                -- Check if there was a healing event in the last 5 seconds
                if (os.time() - event.timestamp) < 5 then
                    hasRecentHealing = true
                    break
                end
            end
        end

        -- Enhanced validation for health regeneration
        if rate and increase then
            -- Adjust threshold based on context
            local adjustedThreshold = regenThreshold
            local reasonSuffix = ""

            -- Adjust threshold for recent healing events
            if hasRecentHealing then
                adjustedThreshold = regenThreshold * 2.0 -- Allow higher regen rate after healing
                reasonSuffix = " (Adjusted for recent healing)"
                confidenceLevel = Detections.confidenceLevels.LOW
            end

            -- Check for armor changes that might be misinterpreted as health regen
            if session.metrics.lastServerArmor and session.metrics.lastServerArmor < (session.metrics.currentArmor or 0) then
                adjustedThreshold = regenThreshold * 1.5 -- Allow higher apparent regen when armor is changing
                reasonSuffix = reasonSuffix .. " (Adjusted for armor change)"
                confidenceLevel = Detections.confidenceLevels.LOW
            end

            -- Check for consistent health regeneration pattern
            local consistentRegen = false
            if session.metrics.healthHistory and #session.metrics.healthHistory >= 3 then
                local regenCount = 0
                for i = 2, #session.metrics.healthHistory do
                    local prev = session.metrics.healthHistory[i - 1]
                    local curr = session.metrics.healthHistory[i]
                    if prev and curr and curr.health > prev.health and not curr.damaged then
                        regenCount = regenCount + 1
                    end
                end

                -- If more than 50% of recent health changes were regeneration without damage, consider it suspicious
                consistentRegen = (regenCount / (#session.metrics.healthHistory - 1)) > 0.5

                if consistentRegen then
                    confidenceLevel = Detections.confidenceLevels.HIGH
                end
            end

            -- Validate based on the server-side regen check logic with context awareness
            if rate > adjustedThreshold and increase > 5.0 then
                isValid = true

                -- Determine severity based on how much the threshold was exceeded and confidence level
                local thresholdExceedFactor = rate / adjustedThreshold

                if thresholdExceedFactor > 3.0 and confidenceLevel >= Detections.confidenceLevels.HIGH then
                    severity = "Critical" -- Extreme regeneration, high confidence
                elseif thresholdExceedFactor > 2.0 or consistentRegen then
                    severity = "High"     -- Significant regeneration or consistent pattern
                elseif thresholdExceedFactor > 1.5 then
                    severity = "Medium"   -- Moderate regeneration
                else
                    severity = "Low"      -- Minor regeneration
                end

                validatedData.reason = string.format(
                    "Health regeneration rate %.2f HP/s (increase %.1f HP) exceeded threshold %.2f HP/s%s (%.1fx, Confidence: %.1f)",
                    rate, increase, adjustedThreshold, reasonSuffix, thresholdExceedFactor, confidenceLevel)

                validatedData.details.rate = rate
                validatedData.details.increase = increase
                validatedData.details.threshold = adjustedThreshold
                validatedData.details.baseThreshold = regenThreshold
                validatedData.details.exceedFactor = thresholdExceedFactor
                validatedData.details.confidence = confidenceLevel
                validatedData.details.consistent = consistentRegen
                validatedData.details.hasRecentHealing = hasRecentHealing
                validatedData.details.timeDiff = validatedData.timeDiff
            end
        elseif detectionType == "GodMode" then
            -- Enhanced server-side validation for client-reported GodMode
            -- Check for suspicious patterns in health history
            if session.metrics.healthHistory and #session.metrics.healthHistory >= 5 then
                local suspiciousPatterns = 0
                local totalDamageEvents = 0

                -- Analyze health history for suspicious patterns
                for i = 2, #session.metrics.healthHistory do
                    local prev = session.metrics.healthHistory[i - 1]
                    local curr = session.metrics.healthHistory[i]

                    -- Count damage events where health didn't decrease
                    if prev and curr and curr.damaged and curr.health >= prev.health then
                        suspiciousPatterns = suspiciousPatterns + 1
                    end

                    -- Count total damage events
                    if curr and curr.damaged then
                        totalDamageEvents = totalDamageEvents + 1
                    end
                end

                -- If player took damage but health didn't decrease in most cases, likely godmode
                if totalDamageEvents >= 3 and (suspiciousPatterns / totalDamageEvents) > 0.7 then
                    isValid = true
                    severity = "High"
                    confidenceLevel = Detections.confidenceLevels.HIGH

                    validatedData.reason = string.format(
                        "Detected %d/%d (%.1f%%) instances where health didn't decrease after damage",
                        suspiciousPatterns, totalDamageEvents, (suspiciousPatterns / totalDamageEvents) * 100)

                    validatedData.details.suspiciousPatterns = suspiciousPatterns
                    validatedData.details.totalDamageEvents = totalDamageEvents
                    validatedData.details.suspiciousRatio = suspiciousPatterns / totalDamageEvents
                    validatedData.details.confidence = confidenceLevel
                end
            end
        end

        validatedData.serverValidated = isValid

    -- Server-Side Armor Check Validation
    elseif detectionType == "ServerArmorCheck" then
        local armor = tonumber(validatedData.armor)
        local maxArmor = Thresholds.serverSideArmorThreshold or 105.0 -- Max allowed armor + tolerance.
        -- Check if reported armor exceeds the configured maximum (Guideline 25).
        if armor and armor > maxArmor then
            isValid = true
            severity = "Medium" -- High armor is suspicious.
            validatedData.reason = string.format("Armor value %.1f exceeded maximum allowed %.1f", armor, maxArmor)
            validatedData.details.armor = armor
            validatedData.details.threshold = maxArmor
        end
        validatedData.serverValidated = isValid

    -- Teleport / Noclip Validation (Includes basic distance and experimental raycast)
    elseif detectionType == "Teleport" or detectionType == "Noclip" or detectionType == "ServerNoclipCheck" then
        -- Basic distance check (less reliable)
        local distance = tonumber(validatedData.distance)
        local timeDiff = tonumber(validatedData.timeDiff)
        if distance and timeDiff then
            -- This check is prone to false positives, keep severity low if relying only on this.
            severity = "Low"
            validatedData.reason = "Potential large distance movement detected (basic check)."
            validatedData.details.distance = distance
            validatedData.details.timeDiff = timeDiff
        end

        -- Experimental Raycasting Check (Guideline 31 Enhancement)
        local currentPos = validatedData.value or validatedData.details.currentPos -- Position reported by client/check
        local lastValidPos = session.metrics.lastValidPosition -- Last position deemed valid by server

        -- Ensure we have valid vector3 positions for raycasting.
        if type(currentPos) == "vector3" and type(lastValidPos) == "vector3" then
            local moveDistance = #(currentPos - lastValidPos)
            local noclipTolerance = Thresholds.noclipTolerance or 3.0 -- Configurable tolerance

            -- Define conditions for performing a raycast check:
            -- - Movement distance is significant (> tolerance).
            -- - Movement distance is not excessively large (to avoid checks on likely admin TPs/respawns).
            local maxSensibleDistance = (Thresholds.serverSideSpeedThreshold or 50.0) * 5.0 -- Heuristic: 5 seconds at max speed threshold
            if moveDistance > noclipTolerance and moveDistance < maxSensibleDistance then
                local sourcePed = Natives.GetPlayerPed(playerId)
                if Natives.DoesEntityExist(sourcePed) then
                    local ignoreEntity = sourcePed -- Ignore the player's own ped in the raycast.
                    local flags = 7 -- Intersect world geometry, objects, vehicles. Adjust as needed.
                    local zOffset = 0.5 -- Raycast slightly above ground level.

                    local rayStart = Natives.vector3(lastValidPos.x, lastValidPos.y, lastValidPos.z + zOffset)
                    local rayEnd = Natives.vector3(currentPos.x, currentPos.y, currentPos.z + zOffset)

                    -- WARNING: Synchronous raycasting with GetShapeTestResult immediately after StartShapeTestRay
                    -- is generally unreliable in FiveM due to its asynchronous nature.
                    -- A robust implementation requires handling the async result, potentially over multiple ticks.
                    -- This example uses a small wait, which is NOT a reliable solution.
                    local rayHandle = Natives.StartShapeTestRay(rayStart.x, rayStart.y, rayStart.z, rayEnd.x, rayEnd.y,
                        rayEnd.z, flags, ignoreEntity, 7)
                    -- !! WARNING: Synchronous raycasting after a small wait is unreliable in FiveM. !!
                    -- !! A robust implementation requires handling async results properly. !!
                    -- !! Consider disabling this check or implementing a proper async handler if issues arise. !!
                    Citizen.Wait(50) -- !! Unreliable wait !!
                    local _, didHit, hitPosition, _, hitEntity = Natives.GetShapeTestResult(rayHandle)

                    if didHit and hitPosition then
                        -- Calculate distance from start to the hit point and total ray distance.
                        local distToHit = #(vector3(hitPosition.x, hitPosition.y, hitPosition.z) - rayStart)
                        local targetDist = #(rayEnd - rayStart)

                        -- If the hit occurred significantly *before* the destination (minus tolerance), flag as potential noclip.
                        if distToHit < (targetDist - noclipTolerance) then
                            isValid = true
                            severity = "High" -- Noclip/Teleport through objects is high severity.
                            validatedData.reason = string.format(
                                "Raycast detected potential noclip/teleport. Hit obstacle (Entity: %s) at [%.1f, %.1f, %.1f] while moving from [%.1f, %.1f, %.1f] to [%.1f, %.1f, %.1f].",
                                tostring(hitEntity or 'unknown'),
                                hitPosition.x, hitPosition.y, hitPosition.z,
                                lastValidPos.x, lastValidPos.y, lastValidPos.z,
                                currentPos.x, currentPos.y, currentPos.z)
                            validatedData.details.raycastHit = true
                            validatedData.details.hitPos = hitPosition
                            validatedData.details.startPos = lastValidPos
                            validatedData.details.endPos = currentPos
                            validatedData.details.hitEntity = hitEntity
                            Log(
                                ("^1[NexusGuard Raycast] Noclip/Teleport detected for %s (ID: %d). Ray hit entity %s.^7")
                                :format(playerName, playerId, tostring(hitEntity or 'unknown')), 1)
                        -- else -- Hit occurred close to destination, likely valid.
                        --    Log(("^3[NexusGuard Raycast] Raycast hit near destination for %s. Likely valid.^7"):format(playerName), 3)
                        end
                    -- else -- Raycast didn't hit anything.
                    --    Log(("^3[NexusGuard Raycast] Raycast path clear for %s.^7"):format(playerName), 3)
                    end
                end
            -- elseif moveDistance >= maxSensibleDistance then -- Log large movements but don't raycast.
            --     Log(("^3[NexusGuard Raycast] Skipping raycast for %s due to large distance (%.1fm). Likely admin TP or respawn.^7"):format(playerName, moveDistance), 3)
            end
        -- else -- Log if positions are invalid for raycasting.
        --    validatedData.reason = "Noclip/Teleport raycast validation requires valid current and last positions."
        end
        validatedData.serverValidated = isValid -- Update status based ONLY on the raycast result for now.

    -- Weapon Mod / Clip Size Check Validation
    elseif detectionType == "WeaponModification" or detectionType == "ServerWeaponClipCheck" then
        -- Extract data from the report (clip size, max allowed, weapon hash).
        local reportedClip = tonumber(validatedData.reportedClip) or tonumber(validatedData.details and validatedData.details.reportedClip)
        local maxAllowed = tonumber(validatedData.maxAllowed) or tonumber(validatedData.details and validatedData.details.maxAllowed)
        local weaponHash = validatedData.weaponHash or (validatedData.details and validatedData.details.weaponHash)

        -- Check if reported clip size exceeds the maximum allowed from config (Guideline 24).
        if reportedClip and maxAllowed and reportedClip > maxAllowed then
            isValid = true
            severity = "High" -- Modified weapon stats are high severity.
            validatedData.reason = string.format("Weapon %s clip size %d exceeded max allowed %d", weaponHash or 'Unknown', reportedClip, maxAllowed)
            validatedData.details.weapon = weaponHash
            validatedData.details.reported = reportedClip
            validatedData.details.allowed = maxAllowed
            validatedData.details.base = validatedData.baseClip or (validatedData.details and validatedData.details.baseClip)
        end
         validatedData.serverValidated = isValid

    -- Resource Mismatch Validation
    elseif detectionType == "ResourceMismatch" then
        -- This detection is generated server-side during the resource check, so it's inherently validated.
        isValid = true
        severity = "Critical" -- Resource tampering is critical severity.
        validatedData.reason = "Unauthorized client resources detected (" .. (validatedData.mode or validatedData.details.mode or "unknown mode") .. ")."
        validatedData.details.mismatched = validatedData.mismatched or validatedData.details.mismatched or {}
        validatedData.serverValidated = true -- Mark as server-validated.

    -- Menu Injection / Detection Validation
    elseif detectionType == "MenuInjection" or detectionType == "MenuDetection" then
         -- Server-side validation for menu injection is extremely difficult and unreliable.
         -- Primarily rely on client-side detection heuristics and resource verification.
         severity = "Critical" -- Assume high risk if client reports this.
         validatedData.reason = "Client reported potential menu keybinds or injection indicators."
         -- We cannot reliably validate this server-side based on the event alone.
         isValid = validatedData.clientValidated -- Trust the client's flag for now, but acknowledge lack of server validation.
         validatedData.serverValidated = false -- Explicitly mark as NOT server-validated.

    -- Handle Unknown Detection Types
    else
        Log(("^3Detections Validation Warning: Received unknown detection type '%s' from %s (ID: %d). Client validated: %s^7"):format(
            detectionType, playerName, playerId, tostring(validatedData.clientValidated)
        ), 2)
        severity = "Info" -- Treat unknown types as informational.
        validatedData.reason = "Unknown detection type received by server."
        isValid = validatedData.clientValidated -- Trust client flag if type is unknown.
        validatedData.serverValidated = false -- Cannot validate unknown types server-side.
    end

    -- 3. Apply Penalties if Server-Side Validation Confirmed the Detection
    if isValid then
        ApplyPenalty(playerId, session, detectionType, validatedData, severity)
    else
        -- Log instances where the client reported a detection, but server-side validation failed.
        -- This helps identify potential false positives from client detectors or areas needing better server validation.
        if validatedData.clientValidated then
             Log(("^2Detections Validation Info: Client flagged '%s' for %s (ID: %d), but server-side validation did not confirm. Reason: %s^7"):format(
                 detectionType, playerName, playerId, validatedData.reason or "Validation failed or insufficient data"
             ), 2)
             -- Optional: Apply a very minor trust penalty or log differently for unconfirmed client flags.
             -- ApplyPenalty(playerId, session, detectionType .. "_ClientOnly", validatedData, "Info")
        -- else -- Optional log for cases where neither client nor server validated (e.g., invalid data received)
             -- Log(("^3Detections Validation Info: Detection '%s' for %s (ID: %d) was not validated by client or server.^7"):format(detectionType, playerName, playerId), 3)
        end
    end

    -- Return the server-side validation status.
    return isValid
end


-- #############################################################################
-- ## Specific Server-Side Validation Functions ##
-- #############################################################################

--[[
    Validates position updates received from the client.
    Checks for speed hacks, teleportation, and noclip issues based on server state.
    Calls ApplyPenalty directly if a violation is confirmed.

    @param playerId (number): The server ID of the player.
    @param currentPos (vector3): The position reported by the client.
    @param clientTimestamp (number): The timestamp sent by the client (less reliable).
    @param session (table): The player's session data object.
]]
function Detections.ValidatePositionUpdate(playerId, currentPos, clientTimestamp, session)
    local playerName = Natives.GetPlayerName(playerId) or ("Unknown (" .. tostring(playerId) .. ")")

    -- Ensure session and metrics are available.
    if not session or not session.metrics then
        Log(("^1Detections Validation Error: Cannot validate position update for %s (ID: %d) - Session or metrics data missing.^7"):format(playerName, playerId), 1)
        return
    end

    -- Access config tables for convenience.
    local cfg = Config
    local Thresholds = cfg.Thresholds or {}

    -- Update player state if not already done in server_main
    if not session.metrics.stateUpdated then
        local ped = Natives.GetPlayerPed(playerId)
        if Natives.DoesEntityExist(ped) then
            -- Update vehicle state
            session.metrics.isInVehicle = Natives.GetVehiclePedIsIn(ped, false) ~= 0

            -- Update movement state
            local velocity = Natives.GetEntityVelocity(ped)
            session.metrics.isFalling = Natives.IsPedFalling(ped)
            session.metrics.isRagdoll = Natives.IsPedRagdoll(ped)
            session.metrics.isSwimming = Natives.IsPedSwimming(ped)
            session.metrics.verticalVelocity = velocity.z
            session.metrics.isInParachute = Natives.IsPedInParachuteFreeFall(ped)
            session.metrics.isGettingUp = Natives.IsPedGettingUp(ped)
            session.metrics.isClimbing = Natives.IsPedClimbing(ped)
            session.metrics.isVaulting = Natives.IsPedVaulting(ped)
            session.metrics.isJumping = Natives.IsPedJumping(ped)

            -- Mark state as updated
            session.metrics.stateUpdated = true
        end
    end

    -- Skip checks during the initial spawn grace period.
    if session.metrics.justSpawned then
        -- Still update the position to prevent large jump detection immediately after grace period ends.
        session.metrics.lastServerPosition = currentPos
        session.metrics.lastServerPositionTimestamp = Natives.GetGameTimer()
        session.metrics.lastValidPosition = currentPos -- Assume spawn position is valid initially.
        return -- Skip validation during grace period.
    end

    -- Skip checks if player just teleported (e.g., via admin command)
    if session.metrics.justTeleported then
        -- Update positions but don't validate
        session.metrics.lastServerPosition = currentPos
        session.metrics.lastServerPositionTimestamp = Natives.GetGameTimer()
        session.metrics.lastValidPosition = currentPos
        return
    end

    -- Load relevant thresholds.
    local serverSpeedThreshold = Thresholds.serverSideSpeedThreshold or 50.0
    local minTimeDiff = Thresholds.minTimeDiffPositionCheck or 450 -- Minimum time between checks (ms).
    local teleportThreshold = Thresholds.teleportThreshold or 100.0 -- Distance in meters that's considered a teleport
    local noclipTolerance = Thresholds.noclipTolerance or 3.0 -- Extra distance tolerance for noclip check.

    -- Perform checks only if enough time has passed since the last check and we have previous position data.
    if session.metrics.lastServerPosition and session.metrics.lastServerPositionTimestamp then
        local lastPos = session.metrics.lastServerPosition
        local lastTimestamp = session.metrics.lastServerPositionTimestamp
        local currentServerTimestamp = Natives.GetGameTimer()
        local timeDiffMs = currentServerTimestamp - lastTimestamp

        if timeDiffMs >= minTimeDiff then
            local distance = #(currentPos - lastPos) -- Calculate distance moved.

            -- Check for teleport (large distance change)
            if distance > teleportThreshold then
                -- Check if this is a legitimate teleport (e.g., admin command, script function)
                local isLegitTeleport = false

                -- Check if player has admin permissions (might be a legitimate admin teleport)
                local Permissions = Core and Core.GetModule and Core.GetModule('Permissions')
                if Permissions and Permissions.IsAdmin then
                    isLegitTeleport = Permissions.IsAdmin(playerId)
                end

                -- If not a legitimate teleport, flag as suspicious
                if not isLegitTeleport then
                    local reason = string.format("Teleport detected: %.2f meters (threshold: %.2f)", distance, teleportThreshold)
                    local details = {
                        distance = distance,
                        threshold = teleportThreshold,
                        fromPos = lastPos,
                        toPos = currentPos,
                        timeDiff = timeDiffMs
                    }

                    -- Apply penalty for teleport detection
                    ApplyPenalty(playerId, session, "ServerTeleportCheck", { reason = reason, details = details, serverValidated = true }, "High")

                    -- Set teleport grace period to avoid multiple detections for the same teleport
                    session.metrics.justTeleported = true
                    local teleportGracePeriod = Thresholds.teleportGracePeriod or 5 -- Default 5 seconds
                    Natives.SetTimeout(teleportGracePeriod * 1000, function()
                        if session and session.metrics then
                            session.metrics.justTeleported = false
                        end
                    end)
                end

                -- Update position data even for teleports
                session.metrics.lastServerPosition = currentPos
                session.metrics.lastServerPositionTimestamp = currentServerTimestamp
                return
            end

            -- Calculate speed in m/s
            local speed = 0.0
            if timeDiffMs > 0 then
                speed = distance / (timeDiffMs / 1000.0)
            end

            -- Adjust speed threshold based on player state.
            local effectiveSpeedThreshold = serverSpeedThreshold
            local reasonSuffix = ""

            -- Check for special movement states that justify higher speeds
            if session.metrics.isFalling or session.metrics.isRagdoll or session.metrics.isInParachute or
               (session.metrics.verticalVelocity and session.metrics.verticalVelocity < -10.0) or
               session.metrics.isGettingUp or session.metrics.isClimbing or session.metrics.isVaulting or
               session.metrics.isJumping then
                effectiveSpeedThreshold = serverSpeedThreshold * 2.5
                reasonSuffix = " (Adjusted for movement state)"
            elseif session.metrics.isInVehicle then
                -- Get vehicle model and adjust threshold based on vehicle type
                local ped = Natives.GetPlayerPed(playerId)
                local vehicle = Natives.GetVehiclePedIsIn(ped, false)
                local vehicleClass = Natives.GetEntityModel(vehicle) -- Use model as fallback for class

                -- Higher threshold for super cars, planes, helicopters
                if vehicleClass == 7 or vehicleClass == 15 or vehicleClass == 16 then
                    effectiveSpeedThreshold = serverSpeedThreshold * 2.0
                else
                    effectiveSpeedThreshold = serverSpeedThreshold * 1.3
                end
                reasonSuffix = " (Adjusted for vehicle class " .. vehicleClass .. ")"
            end

            -- Check if calculated speed exceeds the effective threshold.
            if speed > effectiveSpeedThreshold then
                local reason = string.format("Calculated speed %.2f m/s exceeded threshold %.2f m/s%s", speed, effectiveSpeedThreshold, reasonSuffix)
                local details = {
                    speed = speed,
                    threshold = effectiveSpeedThreshold,
                    distance = distance,
                    timeDiff = timeDiffMs,
                    state = {
                        falling = session.metrics.isFalling,
                        ragdoll = session.metrics.isRagdoll,
                        parachute = session.metrics.isInParachute,
                        inVehicle = session.metrics.isInVehicle,
                        vertVel = session.metrics.verticalVelocity,
                        swimming = session.metrics.isSwimming,
                        climbing = session.metrics.isClimbing,
                        vaulting = session.metrics.isVaulting,
                        jumping = session.metrics.isJumping,
                        gettingUp = session.metrics.isGettingUp
                    }
                }

                -- Store movement sample for pattern analysis
                if not session.metrics.movementSamples then session.metrics.movementSamples = {} end
                table.insert(session.metrics.movementSamples, {
                    timestamp = os.time(),
                    speed = speed,
                    distance = distance,
                    timeDiff = timeDiffMs,
                    position = currentPos,
                    state = details.state
                })

                -- Limit history size
                if #session.metrics.movementSamples > 20 then
                    table.remove(session.metrics.movementSamples, 1)
                end

                -- Apply penalty for speed hack detection
                ApplyPenalty(playerId, session, "ServerSpeedCheck", { reason = reason, details = details, serverValidated = true }, "High")
            else
                -- Perform noclip detection using raycasting if enabled
                if Thresholds.enableNoclipDetection and session.metrics.lastValidPosition then
                    local lastValidPos = session.metrics.lastValidPosition
                    local moveDistance = #(Natives.vector3(currentPos.x, currentPos.y, currentPos.z) - Natives.vector3(lastValidPos.x, lastValidPos.y, lastValidPos.z))

                    -- Only check for noclip if the distance is significant but not too large
                    if moveDistance > noclipTolerance and moveDistance < teleportThreshold / 2 then
                        local sourcePed = Natives.GetPlayerPed(playerId)
                        if sourcePed and sourcePed ~= -1 then
                            -- Perform raycast to check if there are obstacles between positions
                            local rayStart = Natives.vector3(lastValidPos.x, lastValidPos.y, lastValidPos.z + 0.5) -- Offset slightly above ground
                            local rayEnd = Natives.vector3(currentPos.x, currentPos.y, currentPos.z + 0.5)

                            -- Use async raycast with a small wait (not ideal but better than sync)
                            local rayHandle = Natives.StartShapeTestRay(rayStart.x, rayStart.y, rayStart.z, rayEnd.x,
                                rayEnd.y, rayEnd.z, 1, sourcePed, 0)
                            if Citizen then Citizen.Wait(50) end -- Small wait for raycast to complete
                            local retval, hit, endCoords, surfaceNormal, entityHit = Natives.GetShapeTestResult(
                                rayHandle)

                            if hit == 1 and endCoords then -- If raycast hit something and we have valid coordinates
                                local hitPos = Natives.vector3(endCoords.x or 0, endCoords.y or 0, endCoords.z or 0)
                                local distToHit = #(Natives.vector3(hitPos.x, hitPos.y, hitPos.z) - Natives.vector3(rayStart.x, rayStart.y, rayStart.z))
                                local targetDist = #(Natives.vector3(rayEnd.x, rayEnd.y, rayEnd.z) - Natives.vector3(rayStart.x, rayStart.y, rayStart.z))

                                -- If hit occurred significantly before destination, potential noclip
                                if distToHit < (targetDist - noclipTolerance) then
                                    local reason = string.format("Potential noclip detected: Ray hit obstacle at %.1f meters, but player moved %.1f meters", distToHit, targetDist)
                                    local details = {
                                        raycastHit = true,
                                        hitPos = hitPos,
                                        startPos = lastValidPos,
                                        endPos = currentPos,
                                        distToHit = distToHit,
                                        totalDist = targetDist,
                                        entityHit = entityHit
                                    }

                                    -- Apply penalty for noclip detection
                                    ApplyPenalty(playerId, session, "ServerNoclipCheck", { reason = reason, details = details, serverValidated = true }, "High")
                                end
                            end
                        end
                    end
                end

                -- If all checks passed, update last valid position
                session.metrics.lastValidPosition = currentPos
            end
        end
    else
        -- Initialize last valid position on the very first update received
        session.metrics.lastValidPosition = currentPos
    end

    -- Reset state updated flag for next check
    session.metrics.stateUpdated = false

    -- Always update the last known position and timestamp for the next check
    session.metrics.lastServerPosition = currentPos
    session.metrics.lastServerPositionTimestamp = Natives.GetGameTimer()
end

--[[
    Validates health/armor updates received from the client.
    Checks for abnormal regeneration, armor values, and godmode patterns based on server state.
    Calls ApplyPenalty directly if a violation is confirmed.

    @param playerId (number): The server ID of the player.
    @param currentHealth (number): The health value reported by the client.
    @param currentArmor (number): The armor value reported by the client.
    @param clientTimestamp (number): The timestamp sent by the client (not used).
    @param session (table): The player's session data object.
]]
function Detections.ValidateHealthUpdate(playerId, currentHealth, currentArmor, clientTimestamp, session)
    local playerName = Natives.GetPlayerName(playerId) or ("Unknown (" .. tostring(playerId) .. ")")
    -- Ensure session and metrics are available.
    if not session or not session.metrics then
        Log(("^1Detections Validation Error: Cannot validate health update for %s (ID: %d) - Session or metrics data missing.^7"):format(playerName, playerId), 1)
        return
    end

    -- Access config tables for convenience.
    local cfg = Config
    local Thresholds = cfg.Thresholds or {}

    -- Skip checks during the initial spawn grace period.
    if session.metrics.justSpawned then
        -- Still update the health/armor to prevent false detections after grace period ends.
        session.metrics.lastServerHealth = currentHealth
        session.metrics.lastServerArmor = currentArmor
        session.metrics.lastServerHealthTimestamp = Natives.GetGameTimer()
        return -- Skip validation during grace period.
    end

    -- Load relevant thresholds.
    local serverHealthRegenThreshold = Thresholds.serverSideRegenThreshold or 3.0 -- Max HP regen per second.
    local serverArmorMax = Thresholds.serverSideArmorThreshold or 105.0 -- Max allowed armor value + tolerance.
    local minHealthDamageThreshold = Thresholds.minHealthDamageThreshold or 5.0 -- Minimum health damage to consider for godmode detection
    local godModeDetectionWindow = Thresholds.godModeDetectionWindow or 60 -- Time window in seconds for godmode pattern detection

    -- Server-Side Invincibility Check (Guideline 4)
    local isInvincible = Natives.GetPlayerInvincible(playerId)
    if isInvincible then
        local reason = "Server detected player is invincible (GetPlayerInvincible returned true)"
        local details = { invincibleStatus = true }
        -- Apply penalty immediately for server-confirmed invincibility.
        ApplyPenalty(playerId, session, "ServerInvincibleCheck",
            { reason = reason, details = details, serverValidated = true }, "Critical")
        -- Potentially skip further health checks if confirmed invincible, or let them run for logging.
        -- For now, we'll let other checks run too.
    end
    -- Check for suspicious health regeneration.
    if session.metrics.lastServerHealth and session.metrics.lastServerHealthTimestamp then
        local lastHealth = session.metrics.lastServerHealth
        local lastTimestamp = session.metrics.lastServerHealthTimestamp
        local currentServerTimestamp = Natives.GetGameTimer()
        local timeDiffMs = currentServerTimestamp - lastTimestamp

        -- Store health history for pattern analysis
        if not session.metrics.healthHistory then session.metrics.healthHistory = {} end

        -- Add current health reading to history
        table.insert(session.metrics.healthHistory, {
            health = currentHealth,
            armor = currentArmor,
            timestamp = os.time(),
            serverTimestamp = currentServerTimestamp,
            change = currentHealth - lastHealth
        })

        -- Limit history size
        if #session.metrics.healthHistory > 20 then
            table.remove(session.metrics.healthHistory, 1)
        end

        -- Check for health increase (regeneration)
        if currentHealth > lastHealth and timeDiffMs > 500 then
            local healthIncrease = currentHealth - lastHealth
            local regenRate = 0.0
            if timeDiffMs > 0 then regenRate = healthIncrease / (timeDiffMs / 1000.0) end -- Regen rate in HP/sec.

            -- Track consecutive regen violations for sustained increases
            session.metrics.regenViolationCount = session.metrics.regenViolationCount or 0
            if regenRate > serverHealthRegenThreshold then
                session.metrics.regenViolationCount = session.metrics.regenViolationCount + 1
            else
                session.metrics.regenViolationCount = 0
            end

            -- Flag only if regen is sustained or the total increase is large
            if regenRate > serverHealthRegenThreshold and
               (session.metrics.regenViolationCount >= 2 or
                (session.metrics.healthIncreaseBuffer and session.metrics.healthIncreaseBuffer >= serverHealthRegenThreshold * 2)) then
                local reason = string.format("Health regeneration rate %.2f HP/s (increase %.1f HP) exceeded threshold %.2f HP/s",
                    regenRate, healthIncrease, serverHealthRegenThreshold)
                local details = {
                    increase = healthIncrease,
                    rate = regenRate,
                    threshold = serverHealthRegenThreshold,
                    timeDiff = timeDiffMs,
                    lastHealth = lastHealth,
                    currentHealth = currentHealth
                }

                -- Apply penalty for health regeneration violation
                ApplyPenalty(playerId, session, "ServerHealthRegenCheck", { reason = reason, details = details, serverValidated = true }, "Medium")

                -- reset buffer after flagging
                session.metrics.healthIncreaseBuffer = 0
                session.metrics.regenViolationCount = 0
            end
        else
            session.metrics.regenViolationCount = 0
        end

        -- Check for godmode pattern (no health decrease despite taking damage)
        if #session.metrics.healthHistory >= 3 then
            -- Correlate health changes with damage events
            if session.metrics.damageEvents and #session.metrics.damageEvents > 0 then
                -- Calculate expected health after damage
                local expectedHealth = session.metrics.lastServerHealth
                local relevantDamageEvents = 0
                local totalExpectedDamage = 0

                for _, damageEvent in ipairs(session.metrics.damageEvents) do
                    -- Only consider recent damage events
                    if (os.time() - damageEvent.timestamp) < 10 then -- Last 10 seconds
                        relevantDamageEvents = relevantDamageEvents + 1
                        totalExpectedDamage = totalExpectedDamage + damageEvent.damage
                        expectedHealth = math.max(0, expectedHealth - damageEvent.damage)
                    end
                end

                -- If player took significant damage but health didn't decrease appropriately
                if relevantDamageEvents > 0 and totalExpectedDamage > minHealthDamageThreshold and
                    (currentHealth > (expectedHealth + (Thresholds.healthDamageToleranceThreshold or 10.0))) then
                    local reason = string.format(
                        "Health didn't decrease appropriately after taking damage (Current: %.1f, Expected: %.1f, Damage Events: %d)",
                        currentHealth, expectedHealth, relevantDamageEvents)
                    local details = {
                        currentHealth = currentHealth,
                        expectedHealth = expectedHealth,
                        difference = currentHealth - expectedHealth,
                        damageEvents = relevantDamageEvents,
                        totalDamage = totalExpectedDamage
                    }

                    -- Apply penalty for godmode violation
                    ApplyPenalty(playerId, session, "ServerGodModeCheck",
                        { reason = reason, details = details, serverValidated = true }, "High")
                end
            end

            -- Also use pattern-based detection as a fallback
            local godModePattern = DetectGodModePattern(session.metrics.healthHistory, godModeDetectionWindow, minHealthDamageThreshold)

            if godModePattern then
                local reason = "Potential god mode detected: " .. godModePattern.reason
                local details = {
                    pattern = godModePattern.pattern,
                    samples = godModePattern.samples,
                    timeWindow = godModeDetectionWindow
                }

                -- Apply penalty for godmode detection
                ApplyPenalty(playerId, session, "ServerGodModeCheck", { reason = reason, details = details, serverValidated = true }, "High")
            end
        end
    end

    -- Check if current armor exceeds the configured maximum threshold.
    session.metrics.armorOverageCount = session.metrics.armorOverageCount or 0
    if currentArmor > serverArmorMax then
        session.metrics.armorOverageCount = session.metrics.armorOverageCount + 1

        if session.metrics.armorOverageCount >= 2 or currentArmor > (serverArmorMax + 5.0) then
            local reason = string.format("Armor value %.1f exceeded maximum allowed %.1f", currentArmor, serverArmorMax)
            local details = {
                armor = currentArmor,
                threshold = serverArmorMax
            }

            -- Apply penalty for armor violation
            ApplyPenalty(playerId, session, "ServerArmorCheck", { reason = reason, details = details, serverValidated = true }, "Medium")

            session.metrics.armorOverageCount = 0
        end
    else
        session.metrics.armorOverageCount = 0
    end

    -- Update the last known health, armor, and timestamp in the session metrics.
    session.metrics.lastServerHealth = currentHealth
    session.metrics.lastServerArmor = currentArmor
    session.metrics.lastServerHealthTimestamp = GetGameTimer()
end

--[[
    Analyzes health history to detect godmode patterns.
    Looks for patterns like no health decrease despite taking damage.

    @param healthHistory (table): Array of health history entries.
    @param timeWindow (number): Time window in seconds to analyze.
    @param minDamageThreshold (number): Minimum health damage to consider.
    @return (table|nil): Detection details if godmode pattern found, nil otherwise.
]]
function DetectGodModePattern(healthHistory, timeWindow, minDamageThreshold)
    if not healthHistory or #healthHistory < 3 then return nil end

    local currentTime = os.time()
    local recentHistory = {}

    -- Filter to recent entries within the time window
    for _, entry in ipairs(healthHistory) do
        if currentTime - entry.timestamp <= timeWindow then
            table.insert(recentHistory, entry)
        end
    end

    if #recentHistory < 3 then return nil end

    -- Look for suspicious patterns
    local noHealthDecrease = true
    local minHealth = recentHistory[1].health
    local maxHealth = recentHistory[1].health

    for _, entry in ipairs(recentHistory) do
        minHealth = math.min(minHealth, entry.health)
        maxHealth = math.max(maxHealth, entry.health)

        -- If we see any significant health decrease, not godmode
        if entry.change and entry.change < -minDamageThreshold then
            noHealthDecrease = false
            break
        end
    end

    -- If health never decreased significantly but had variation (indicating potential damage events)
    -- and we have enough samples, flag as potential godmode
    if noHealthDecrease and (maxHealth - minHealth) < minDamageThreshold and #recentHistory >= 5 then
        return {
            reason = string.format("No significant health decrease over %d seconds despite health variations", timeWindow),
            pattern = "no_decrease",
            samples = #recentHistory
        }
    end

    -- Check for perfect health maintenance (always exactly 100 or 200)
    local perfectHealth = true
    local healthValue = recentHistory[1].health

    for _, entry in ipairs(recentHistory) do
        if entry.health ~= healthValue then
            perfectHealth = false
            break
        end
    end

    if perfectHealth and #recentHistory >= 5 and (healthValue == 100 or healthValue == 200) then
        return {
            reason = string.format("Health maintained at exactly %.1f for %d seconds", healthValue, timeWindow),
            pattern = "perfect_health",
            samples = #recentHistory
        }
    end

    return nil
end


-- #############################################################################
-- ## Damage Event Tracking ##
-- #############################################################################

--[[
    Tracks a damage event for a player.
    This should be called when a player takes damage from any source.

    @param playerId (number): The server ID of the player who took damage.
    @param damageAmount (number): The amount of damage taken.
    @param weaponHash (number): The weapon hash that caused the damage.
    @param attacker (number): The server ID of the attacker (if applicable).
]]
function Detections.TrackDamageEvent(playerId, damageAmount, weaponHash, attacker)
    -- Get the player's session
    local session = Core.GetSession(playerId)
    if not session or not session.metrics then return end

    -- Initialize damage events array if it doesn't exist
    if not session.metrics.damageEvents then
        session.metrics.damageEvents = {}
    end

    -- Add the damage event
    table.insert(session.metrics.damageEvents, {
        damage = damageAmount,
        weapon = weaponHash,
        attacker = attacker,
        timestamp = os.time()
    })

    -- Mark the most recent health history entry as damaged
    if session.metrics.healthHistory and #session.metrics.healthHistory > 0 then
        session.metrics.healthHistory[#session.metrics.healthHistory].damaged = true
    end

    -- Limit history size
    if #session.metrics.damageEvents > 20 then
        table.remove(session.metrics.damageEvents, 1)
    end
end
-- #############################################################################
-- ## History and Pattern Analysis ##
-- #############################################################################

--[[
    Add a detection to the player's history for pattern analysis.
    @param playerId (number): The server ID of the player.
    @param detectionType (string): The type of detection.
    @param details (table): Additional details about the detection.
    @param severity (string): The severity level of the detection.
    @param confidence (number): The confidence level of the detection (0.0 to 1.0).
]]
function Detections.AddToHistory(playerId, detectionType, details, severity, confidence)
    -- Initialize player history if it doesn't exist
    if not Detections.history[playerId] then
        Detections.history[playerId] = {}
    end

    -- Add the detection to history
    table.insert(Detections.history[playerId], {
        type = detectionType,
        details = details,
        severity = severity,
        confidence = confidence,
        timestamp = os.time()
    })

    -- Limit history size to prevent memory bloat
    while #Detections.history[playerId] > Detections.defaultThresholds.maxHistorySize do
        table.remove(Detections.history[playerId], 1)
    end

    -- Update pattern analysis
    Detections.AnalyzePatterns(playerId)
end

--[[
    Analyze detection patterns for a player.
    @param playerId (number): The server ID of the player.
    @return (table): A table of detected patterns.
]]
function Detections.AnalyzePatterns(playerId)
    if not Detections.history[playerId] or #Detections.history[playerId] < 2 then
        return {}
    end

    local patterns = {}
    local currentTime = os.time()
    local timeWindow = Detections.defaultThresholds.patternTimeWindow
    local threshold = Detections.defaultThresholds.patternDetectionThreshold

    -- Count detections by type within the time window
    local typeCounts = {}
    for _, detection in ipairs(Detections.history[playerId]) do
        if currentTime - detection.timestamp <= timeWindow then
            typeCounts[detection.type] = (typeCounts[detection.type] or 0) + 1
        end
    end

    -- Identify patterns based on frequency
    for detectionType, count in pairs(typeCounts) do
        if count >= threshold then
            table.insert(patterns, {
                type = detectionType,
                count = count,
                timeWindow = timeWindow
            })
        end
    end

    -- Store patterns for this player
    Detections.patterns[playerId] = patterns

    return patterns
end

--[[
    Calculate detection severity based on multiple factors.
    @param playerId (number): The server ID of the player.
    @param detectionType (string): The type of detection.
    @param baseConfidence (number): The base confidence level (0.0 to 1.0).
    @param session (table): The player's session data.
    @return (string, number): The severity level and adjusted confidence.
]]
function Detections.CalculateSeverity(playerId, detectionType, baseConfidence, session)
    -- Default to medium severity if we can't determine better
    local severity = Detections.severityLevels.MEDIUM
    local confidence = baseConfidence or Detections.confidenceLevels.MEDIUM

    -- Get config severity scores
    local cfg = Config
    local severityScore = (cfg.SeverityScores and cfg.SeverityScores[detectionType]) or
                          (cfg.SeverityScores and cfg.SeverityScores.default) or 5

    -- Adjust based on detection history
    local historyFactor = 1.0
    if Detections.history[playerId] then
        local recentDetections = 0
        local currentTime = os.time()

        -- Count recent detections of the same type
        for _, detection in ipairs(Detections.history[playerId]) do
            if detection.type == detectionType and currentTime - detection.timestamp <= 300 then
                recentDetections = recentDetections + 1
            end
        end

        -- Increase confidence based on repeated detections
        if recentDetections > 0 then
            historyFactor = math.min(2.0, 1.0 + (recentDetections * 0.2))
        end
    end

    -- Adjust confidence based on history
    confidence = math.min(Detections.confidenceLevels.CERTAIN, confidence * historyFactor)

    -- Determine severity based on confidence and severity score
    if confidence >= Detections.confidenceLevels.HIGH then
        if severityScore >= 15 then
            severity = Detections.severityLevels.CRITICAL
        else
            severity = Detections.severityLevels.HIGH
        end
    elseif confidence >= Detections.confidenceLevels.MEDIUM then
        if severityScore >= 10 then
            severity = Detections.severityLevels.HIGH
        else
            severity = Detections.severityLevels.MEDIUM
        end
    elseif confidence >= Detections.confidenceLevels.LOW then
        severity = Detections.severityLevels.LOW
    else
        severity = Detections.severityLevels.INFO
    end

    -- Consider player trust score if available
    if session and session.metrics and session.metrics.trustScore then
        local trustScore = session.metrics.trustScore

        -- Lower trust score increases severity
        if trustScore < 50 and severity ~= Detections.severityLevels.CRITICAL then
            -- Escalate severity by one level if trust is low
            if severity == Detections.severityLevels.HIGH then
                severity = Detections.severityLevels.CRITICAL
            elseif severity == Detections.severityLevels.MEDIUM then
                severity = Detections.severityLevels.HIGH
            elseif severity == Detections.severityLevels.LOW then
                severity = Detections.severityLevels.MEDIUM
            end
        end
    end

    return severity, confidence
end

--[[
    Determine the appropriate response based on detection severity and player history.
    @param playerId (number): The server ID of the player.
    @param detectionType (string): The type of detection.
    @param severity (string): The severity level of the detection.
    @param session (table): The player's session data.
    @return (string): The response action to take.
]]
function Detections.DetermineResponse(playerId, detectionType, severity, session)
    -- Default response is to log only
    local response = "log"

    -- Get config action settings
    local cfg = Config
    local Actions = cfg.Actions or {}

    -- Get trust score if available
    local trustScore = (session and session.metrics and session.metrics.trustScore) or 100

    -- Determine response based on severity and trust score
    if severity == Detections.severityLevels.CRITICAL then
        if Actions.banOnConfirmed then
            response = "ban"
        else
            response = "kick"
        end
    elseif severity == Detections.severityLevels.HIGH then
        if trustScore <= 50 and Actions.banOnConfirmed then
            response = "ban"
        elseif Actions.kickOnSuspicion then
            response = "kick"
        else
            response = "warn"
        end
    elseif severity == Detections.severityLevels.MEDIUM then
        if trustScore <= 30 and Actions.kickOnSuspicion then
            response = "kick"
        else
            response = "warn"
        end
    elseif severity == Detections.severityLevels.LOW then
        response = "warn"
    else
        response = "log"
    end

    -- Check for specific action config for this detection type
    local typeActions = Actions[detectionType]
    if typeActions then
        if typeActions.alwaysBan then
            response = "ban"
        elseif typeActions.alwaysKick then
            response = "kick"
        elseif typeActions.neverBan and response == "ban" then
            response = "kick"
        elseif typeActions.neverKick and (response == "kick" or response == "ban") then
            response = "warn"
        end
    end

    return response
end

--[[
    Cleanup old detection data to prevent memory bloat.
]]
function Detections.Cleanup()
    local currentTime = Natives.GetGameTimer()

    -- Only run cleanup at the specified interval
    if currentTime - Detections.defaultThresholds.lastCleanup < Detections.defaultThresholds.cleanupInterval then
        return
    end

    Detections.defaultThresholds.lastCleanup = currentTime
    local connectedPlayers = Natives.GetPlayers()
    local connectedIds = {}

    -- Create a lookup table of connected player IDs
    for _, id in ipairs(connectedPlayers) do
        connectedIds[tonumber(id)] = true
    end

    -- Remove data for disconnected players
    for playerId, _ in pairs(Detections.history) do
        if not connectedIds[playerId] then
            Detections.history[playerId] = nil
            Detections.patterns[playerId] = nil
            Log(string.format("^3[Detections]^7 Cleaned up detection data for disconnected player ID: %d", playerId), 3)
        end
    end
end

--[[
    Get detection history for a player.
    @param playerId (number): The server ID of the player.
    @return (table): The player's detection history.
]]
function Detections.GetPlayerHistory(playerId)
    return Detections.history[playerId] or {}
end

--[[
    Get detected patterns for a player.
    @param playerId (number): The server ID of the player.
    @return (table): The player's detected patterns.
]]
function Detections.GetPlayerPatterns(playerId)
    return Detections.patterns[playerId] or {}
end

-- Modify the Process function to use the new features
local originalProcess = Detections.Process
Detections.Process = function(playerId, detectionType, detectionData, session)
    -- Run cleanup periodically
    Detections.Cleanup()

    -- Call the original Process function
    local isValid = originalProcess(playerId, detectionType, detectionData, session)

    -- If the detection was valid, add it to history and analyze patterns
    if isValid then
        -- Determine confidence level based on validation
        local confidence = detectionData.serverValidated and Detections.confidenceLevels.HIGH or
                          (detectionData.clientValidated and Detections.confidenceLevels.MEDIUM or
                           Detections.confidenceLevels.LOW)

        -- Calculate severity with context awareness
        local severity, adjustedConfidence = Detections.CalculateSeverity(playerId, detectionType, confidence, session)

        -- Add to history for pattern analysis
        Detections.AddToHistory(playerId, detectionType, detectionData.details, severity, adjustedConfidence)

        -- Determine appropriate response
        local response = Detections.DetermineResponse(playerId, detectionType, severity, session)

        -- Log the determined response
        Log(string.format("^3[Detections]^7 Response for %s (ID: %d), Type: %s, Severity: %s, Confidence: %.2f - Action: %s",
            GetPlayerName(playerId) or "Unknown", playerId, detectionType, severity, adjustedConfidence, response), 2)
    end

    return isValid
end

-- Export the Detections table.
return Detections
