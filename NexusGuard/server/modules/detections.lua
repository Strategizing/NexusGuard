--[[
    NexusGuard Enhanced Detection System (server/modules/detections.lua)

    Purpose:
    - Central logic for processing detection reports received from clients or generated by server-side checks
    - Validates the received data against server-side logic and configuration thresholds
    - Determines the severity of the detection with context-aware analysis
    - Applies penalties based on severity and trust score, including logging, trust score reduction,
      Discord notifications, and potentially kicks or bans
    - Provides advanced detection capabilities with pattern recognition and behavioral analysis

    Key Features:
    - Context-aware validation that considers player state and game mechanics
    - Severity calculation based on multiple factors (not just detection type)
    - Automatic response system that scales based on detection severity and history
    - Integration with existing ban/kick system
    - Advanced pattern recognition for detecting sophisticated cheats

    Dependencies:
    - Global `NexusGuardServer` API table (for Config, Utils, Bans, Discord)
    - `ox_lib` resource (for `lib.json`)

    Usage:
    - Required by `globals.lua` and exposed via the `NexusGuardServer.Detections` API table
    - The `Process` function is the main entry point, called by event handlers in `server_main.lua`
      or potentially other server-side checks
]]
local Detections = {
    -- Store detection history for pattern analysis
    history = {},

    -- Store player behavior patterns
    patterns = {},

    -- Detection confidence levels
    confidenceLevels = {
        NONE = 0,       -- No confidence (0%)
        VERY_LOW = 0.2, -- Very low confidence (20%)
        LOW = 0.4,      -- Low confidence (40%)
        MEDIUM = 0.6,   -- Medium confidence (60%)
        HIGH = 0.8,     -- High confidence (80%)
        CERTAIN = 1.0   -- Certain (100%)
    },

    -- Detection severity levels
    severityLevels = {
        INFO = "Info",         -- Informational, no action needed
        LOW = "Low",           -- Low severity, monitor only
        MEDIUM = "Medium",     -- Medium severity, potential issue
        HIGH = "High",         -- High severity, likely cheating
        CRITICAL = "Critical"  -- Critical severity, definite cheating
    },

    -- Default thresholds for various detection types
    defaultThresholds = {
        -- Time window for pattern analysis (in seconds)
        patternTimeWindow = 300,  -- 5 minutes

        -- Number of similar detections to trigger pattern recognition
        patternDetectionThreshold = 3,

        -- Maximum history size per player
        maxHistorySize = 50,

        -- Cleanup interval (in milliseconds)
        cleanupInterval = 300000,  -- 5 minutes

        -- Last cleanup timestamp
        lastCleanup = 0
    }
}

-- Attempt to get the NexusGuard Server API from globals.lua. Use pcall for safety.
local successAPI, NexusGuardServer = pcall(function() return exports['NexusGuard']:GetNexusGuardServerAPI() end)
if not successAPI or not NexusGuardServer then
    print("^1[NexusGuard Detections] CRITICAL: Failed to get NexusGuardServer API. Detections module will not function.^7")
    -- Create dummy API to prevent immediate errors, although functionality will be broken.
    NexusGuardServer = NexusGuardServer or {
        Config = { Thresholds = {}, Severity = {}, Actions = {} },
        Utils = { Log = function(...) print("[NexusGuard Detections Fallback Log]", ...) end },
        Bans = {}, Discord = {}
    }
end

-- Local alias for the logging function.
local Log = NexusGuardServer.Utils.Log

-- Attempt to load ox_lib for JSON encoding/decoding
local hasOxLib = pcall(function() return lib ~= nil and lib.json ~= nil end)
if not hasOxLib then
    Log("^3[NexusGuard Detections] WARNING: ox_lib JSON functions not available. Some features may be limited.^7", 2)
end

--[[
    Validates the basic structure of incoming detection data.
    Ensures it's a table and contains expected (even if nil) fields.

    @param detectionData (any): The raw data received with the detection report.
    @return (table): A validated table structure, potentially wrapping non-table input.
]]
local function ValidateDetectionData(detectionData)
    if type(detectionData) ~= "table" then
        Log(("^1Detections Validation Warning: Received non-table detection data (%s). Wrapping it.^7"):format(type(detectionData)), 1)
        -- Wrap non-table data for consistency, assume client validation failed.
        return { value = detectionData, details = {}, clientValidated = false }
    end
    -- Ensure essential fields exist, defaulting if necessary.
    detectionData.value = detectionData.value -- The primary value reported (e.g., speed, health).
    detectionData.details = detectionData.details or {} -- Additional contextual details.
    detectionData.clientValidated = detectionData.clientValidated or false -- Flag indicating if the client-side detector triggered this report.
    return detectionData
end

--[[
    Applies penalties based on a validated detection.
    - Logs the detection event.
    - Reduces the player's trust score based on severity.
    - Stores the detection event in the player's session metrics.
    - Sends a Discord notification (if configured).
    - Executes kick/ban actions based on trust score thresholds defined in config.

    @param playerId (number): The server ID of the player.
    @param session (table): The player's session data object.
    @param detectionType (string): The type of detection.
    @param validatedData (table): The validated detection data, including server-side validation results/reason.
    @param severity (string): The determined severity ("Low", "Medium", "High", "Critical", "Info").
]]
local function ApplyPenalty(playerId, session, detectionType, validatedData, severity)
    local playerName = GetPlayerName(playerId) or ("Unknown (" .. tostring(playerId) .. ")")
    local reason = validatedData.reason or "No specific reason provided."
    local details = validatedData.details or {}
    -- Determine trust score impact based on severity config, with defaults.
    local trustImpact = (NexusGuardServer.Config.Severity and NexusGuardServer.Config.Severity[detectionType]) or
                        (NexusGuardServer.Config.Severity and NexusGuardServer.Config.Severity.default) or 5

    -- Ensure JSON encoding is safe for logging details.
    local detailsJson = "error encoding"
    if lib and lib.json then
        local encSuccess, encResult = pcall(lib.json.encode, details)
        if encSuccess then detailsJson = encResult end
    end

    -- Log the confirmed detection event.
    Log(("^1[NexusGuard Detection Confirmed]^7 Player: %s (ID: %d) | Type: %s | Severity: %s | Reason: %s | Details: %s^7"):format(
        playerName, playerId, detectionType, severity, reason, detailsJson
    ), 1)

    -- Update Trust Score in session metrics.
    if session and session.metrics then
        local oldTrust = session.metrics.trustScore or 100
        session.metrics.trustScore = math.max(0, oldTrust - trustImpact) -- Clamp score at 0.
        Log(("^3[NexusGuard Trust]^7 Trust score for %s (ID: %d) reduced by %d due to %s. New score: %.1f^7"):format(
            playerName, playerId, trustImpact, detectionType, session.metrics.trustScore
        ), 2)

        -- Store the detection event details within the session metrics.
        if not session.metrics.detections then session.metrics.detections = {} end
        table.insert(session.metrics.detections, {
            type = detectionType,
            reason = reason,
            details = details, -- Store original table, not JSON
            severity = severity,
            trustImpact = trustImpact,
            timestamp = os.time()
        })
        -- Also store in database if configured
        if NexusGuardServer.Database and NexusGuardServer.Database.StoreDetection then
            NexusGuardServer.Database.StoreDetection(playerId, detectionType, details) -- Pass original details table
        end
    else
         Log(("^1Detections Penalty Warning: Cannot apply trust score penalty or store detection for %s (ID: %d) - session or metrics missing.^7"):format(playerName, playerId), 1)
    end

    -- Send Discord Notification via Discord module API.
    if NexusGuardServer.Discord and NexusGuardServer.Discord.Send then
        -- Prepare data for embed fields
        local embedData = {
            { name = "Player", value = string.format("%s (`%d`)", playerName, playerId), inline = true },
            { name = "Detection", value = detectionType, inline = true },
            { name = "Severity", value = severity, inline = true },
            { name = "Reason", value = reason, inline = false },
            { name = "Details", value = string.format("```json\n%s\n```", detailsJson), inline = false }, -- Use code block for JSON
            { name = "Trust Score", value = string.format("%.1f (`-%d`)", session and session.metrics and session.metrics.trustScore or -1.0, trustImpact), inline = true }
        }
        -- Determine the correct webhook URL (category-specific or general).
        local webhook = NexusGuardServer.Config.Discord and NexusGuardServer.Config.Discord.webhooks and NexusGuardServer.Config.Discord.webhooks.detections
        -- Pass the embedData table instead of the formatted string
        NexusGuardServer.Discord.Send("detections", "Suspicious Activity Detected", embedData, webhook)
    end

    -- Execute Actions (Ban/Kick) based on trust score thresholds defined in config.
    -- TODO: Implement more sophisticated progressive banning logic (e.g., based on frequency/severity of recent detections).
    local actionConfig = (NexusGuardServer.Config.Actions and NexusGuardServer.Config.Actions[detectionType]) or
                         (NexusGuardServer.Config.Actions and NexusGuardServer.Config.Actions.default) or
                         { kickThreshold = 50, banThreshold = 20 } -- Default thresholds if not configured.
    local currentTrust = (session and session.metrics and session.metrics.trustScore) or 100.0 -- Default to 100 if unavailable.

    -- Check Ban Threshold
    if currentTrust <= actionConfig.banThreshold then
        Log(("^1[NexusGuard Action]^7 Trust score (%.1f) reached ban threshold (<= %.1f) for detection '%s'. Banning %s (ID: %d).^7"):format(
            currentTrust, actionConfig.banThreshold, detectionType, playerName, playerId
        ), 1)
        -- Execute ban via Bans module API.
        if NexusGuardServer.Bans and NexusGuardServer.Bans.Execute then
            local banReason = ("Automatic ban: Triggered %s (Trust Score: %.1f)"):format(detectionType, currentTrust)
            NexusGuardServer.Bans.Execute(playerId, banReason, "NexusGuard System") -- Default to permanent ban.
        else
             Log("^1Detections Action Error: Bans.Execute function missing from API. Cannot ban player. Kicking as fallback.^7", 1)
             DropPlayer(playerId, "Kicked by Anti-Cheat (System Error: Ban Function Missing)")
        end
    -- Check Kick Threshold (only if not banned)
    elseif currentTrust <= actionConfig.kickThreshold then
        Log(("^1[NexusGuard Action]^7 Trust score (%.1f) reached kick threshold (<= %.1f) for detection '%s'. Kicking %s (ID: %d).^7"):format(
            currentTrust, actionConfig.kickThreshold, detectionType, playerName, playerId
        ), 1)
        local kickReason = ("Kicked by Anti-Cheat: Triggered %s (Trust Score: %.1f)"):format(detectionType, currentTrust)
        DropPlayer(playerId, kickReason)
    end
end

--[[
    Main processing function for detection reports.
    Validates incoming data, performs server-side checks, determines severity, and applies penalties.

    @param playerId (number): The server ID of the player associated with the detection.
    @param detectionType (string): A string identifying the type of detection (e.g., "SpeedHack", "GodMode", "ServerSpeedCheck").
    @param detectionData (table): A table containing details reported by the client detector or server-side check.
                                  Expected fields vary by detection type but often include `value`, `details`, `clientValidated`.
    @param session (table): The player's session data object, containing metrics and state.
    @return (boolean): True if the detection was validated server-side, false otherwise.
]]
function Detections.Process(playerId, detectionType, detectionData, session)
    -- Ensure essential components are loaded.
    if not NexusGuardServer or not Log then print("^1[NexusGuard Detections] CRITICAL: NexusGuardServer API or Log function not available. Cannot process detection.^7"); return false end

    local playerName = GetPlayerName(playerId) or ("Unknown (" .. tostring(playerId) .. ")")
    Log(("^3Detections: Processing report for player %s (ID: %d), Type: %s^7"):format(playerName, playerId, detectionType), 3)

    -- 1. Validate Input Data Structure: Ensure detectionData is a table with expected base fields.
    local validatedData = ValidateDetectionData(detectionData)
    validatedData.serverValidated = false -- Initialize server validation status for this run.
    validatedData.reason = validatedData.reason or "Initial report received" -- Default reason if none provided.

    -- 2. Perform Server-Side Validation: Check the data against server logic and config.
    local isValid = false          -- Flag indicating if server-side checks confirm the detection.
    local severity = "Low"         -- Default severity, adjusted based on validation.

    -- Ensure session and metrics are available, as they are crucial for most validations.
    if not session or not session.metrics then
        Log(("^1Detections Validation Error: Cannot validate detection '%s' for %s (ID: %d) - Session or metrics data missing.^7"):format(detectionType, playerName, playerId), 1)
        -- Cannot proceed with validation without session data.
        return false
    end

    -- Access config tables via the API object for convenience.
    local Config = NexusGuardServer.Config
    local Thresholds = Config.Thresholds or {}
    local Features = Config.Features or {}

    -- --- Specific Detection Type Validation Logic ---
    -- Use 'elseif' structure to handle different detection types.

    -- Speed Hack / Server Speed Check Validation
    if detectionType == "SpeedHack" or detectionType == "ServerSpeedCheck" then
        -- Extract speed value (might come from client 'value' or server 'calculatedSpeed').
        local speed = tonumber(validatedData.value) or tonumber(validatedData.calculatedSpeed) or tonumber(validatedData.details and validatedData.details.speed)
        if speed then
            local baseThreshold = Thresholds.serverSideSpeedThreshold or 50.0 -- Base speed limit (m/s).
            local effectiveThreshold = baseThreshold
            local reasonSuffix = ""

            -- Adjust threshold based on player state stored in session metrics (Guideline 26, 38).
            if session.metrics.isFalling or session.metrics.isRagdoll or session.metrics.isInParachute or (session.metrics.verticalVelocity and session.metrics.verticalVelocity < -10.0) then
                effectiveThreshold = baseThreshold * 2.5 -- Allow significantly higher speed if falling/ragdolling/parachuting.
                reasonSuffix = " (Adjusted for falling/ragdoll/parachute)"
            elseif session.metrics.isInVehicle then
                effectiveThreshold = baseThreshold * 1.3 -- Allow slightly higher speed in vehicles.
                reasonSuffix = " (Adjusted for vehicle)"
            end

            -- Check if calculated speed exceeds the adjusted threshold.
            if speed > effectiveThreshold then
                isValid = true
                severity = "High" -- Speeding is usually high severity.
                validatedData.reason = string.format("Calculated speed %.2f m/s exceeded threshold %.2f m/s%s", speed, effectiveThreshold, reasonSuffix)
                -- Store relevant details for logging/review.
                validatedData.details.speed = speed
                validatedData.details.threshold = effectiveThreshold
                validatedData.details.state = { falling=session.metrics.isFalling, ragdoll=session.metrics.isRagdoll, parachute=session.metrics.isInParachute, inVehicle=session.metrics.isInVehicle, vertVel=session.metrics.verticalVelocity }
            end
        else
            -- If speed value is missing or invalid.
            validatedData.reason = "Invalid or missing speed value in detection data."
            severity = "Info" -- Treat as informational, not a confirmed cheat.
        end
        validatedData.serverValidated = isValid -- Update server validation status.

    -- God Mode / Health Regeneration Check Validation
    elseif detectionType == "GodMode" or detectionType == "ServerHealthRegenCheck" then
        -- Extract data specific to the server-side health regen check.
        local increase = tonumber(validatedData.increase)
        local rate = tonumber(validatedData.rate)
        local regenThreshold = Thresholds.serverSideRegenThreshold or 3.0 -- Max allowed HP/sec regen.

        -- Validate based on the server-side regen check logic (Guideline 29).
        -- Requires significant increase AND rate exceeding threshold.
        if rate and increase and rate > regenThreshold and increase > 5.0 then
             isValid = true
             severity = "Medium" -- Suspicious regen is medium severity.
             validatedData.reason = string.format("Health regeneration rate %.2f HP/s (increase %.1f HP) exceeded threshold %.2f HP/s", rate, increase, regenThreshold)
             validatedData.details.rate = rate
             validatedData.details.increase = increase
             validatedData.details.threshold = regenThreshold
             validatedData.details.timeDiff = validatedData.timeDiff
        else
            -- TODO: Add server-side validation logic for "GodMode" reports from client.
            -- This might involve checking recent damage events vs health changes stored in session.metrics.healthHistory.
            -- For now, if it's just "GodMode" without regen data, we don't have server validation.
            -- validatedData.reason = "GodMode validation requires health history analysis (Not Implemented)."
        end
         validatedData.serverValidated = isValid

    -- Server-Side Armor Check Validation
    elseif detectionType == "ServerArmorCheck" then
        local armor = tonumber(validatedData.armor)
        local maxArmor = Thresholds.serverSideArmorThreshold or 105.0 -- Max allowed armor + tolerance.
        -- Check if reported armor exceeds the configured maximum (Guideline 25).
        if armor and armor > maxArmor then
            isValid = true
            severity = "Medium" -- High armor is suspicious.
            validatedData.reason = string.format("Armor value %.1f exceeded maximum allowed %.1f", armor, maxArmor)
            validatedData.details.armor = armor
            validatedData.details.threshold = maxArmor
        end
        validatedData.serverValidated = isValid

    -- Teleport / Noclip Validation (Includes basic distance and experimental raycast)
    elseif detectionType == "Teleport" or detectionType == "Noclip" or detectionType == "ServerNoclipCheck" then
        -- Basic distance check (less reliable)
        local distance = tonumber(validatedData.distance)
        local timeDiff = tonumber(validatedData.timeDiff)
        if distance and timeDiff then
            -- This check is prone to false positives, keep severity low if relying only on this.
            severity = "Low"
            validatedData.reason = "Potential large distance movement detected (basic check)."
            validatedData.details.distance = distance
            validatedData.details.timeDiff = timeDiff
        end

        -- Experimental Raycasting Check (Guideline 31 Enhancement)
        local currentPos = validatedData.value or validatedData.details.currentPos -- Position reported by client/check
        local lastValidPos = session.metrics.lastValidPosition -- Last position deemed valid by server

        -- Ensure we have valid vector3 positions for raycasting.
        if type(currentPos) == "vector3" and type(lastValidPos) == "vector3" then
            local moveDistance = #(currentPos - lastValidPos)
            local noclipTolerance = Thresholds.noclipTolerance or 3.0 -- Configurable tolerance

            -- Define conditions for performing a raycast check:
            -- - Movement distance is significant (> tolerance).
            -- - Movement distance is not excessively large (to avoid checks on likely admin TPs/respawns).
            local maxSensibleDistance = (Thresholds.serverSideSpeedThreshold or 50.0) * 5.0 -- Heuristic: 5 seconds at max speed threshold
            if moveDistance > noclipTolerance and moveDistance < maxSensibleDistance then
                local sourcePed = GetPlayerPed(playerId)
                if sourcePed and sourcePed ~= -1 then
                    local ignoreEntity = sourcePed -- Ignore the player's own ped in the raycast.
                    local flags = 7 -- Intersect world geometry, objects, vehicles. Adjust as needed.
                    local zOffset = 0.5 -- Raycast slightly above ground level.

                    local rayStart = vector3(lastValidPos.x, lastValidPos.y, lastValidPos.z + zOffset)
                    local rayEnd = vector3(currentPos.x, currentPos.y, currentPos.z + zOffset)

                    -- WARNING: Synchronous raycasting with GetShapeTestResult immediately after StartShapeTestRay
                    -- is generally unreliable in FiveM due to its asynchronous nature.
                    -- A robust implementation requires handling the async result, potentially over multiple ticks.
                    -- This example uses a small wait, which is NOT a reliable solution.
                    local rayHandle = StartShapeTestRay(rayStart.x, rayStart.y, rayStart.z, rayEnd.x, rayEnd.y, rayEnd.z, flags, ignoreEntity, 7)
                    Citizen.Wait(50) -- !! Unreliable wait !! A proper async handler is needed.
                    local didHit, hitPosition, hitNormal, hitEntity = GetShapeTestResult(rayHandle)

                    if didHit then
                        -- Calculate distance from start to the hit point and total ray distance.
                        local distToHit = #(vector3(hitPosition.x, hitPosition.y, hitPosition.z) - rayStart)
                        local targetDist = #(rayEnd - rayStart)

                        -- If the hit occurred significantly *before* the destination (minus tolerance), flag as potential noclip.
                        if distToHit < (targetDist - noclipTolerance) then
                            isValid = true
                            severity = "High" -- Noclip/Teleport through objects is high severity.
                            validatedData.reason = string.format("Raycast detected potential noclip/teleport. Hit obstacle (Entity: %s) at [%.1f, %.1f, %.1f] while moving from [%.1f, %.1f, %.1f] to [%.1f, %.1f, %.1f].", tostring(hitEntity), hitPosition.x, hitPosition.y, hitPosition.z, lastValidPos.x, lastValidPos.y, lastValidPos.z, currentPos.x, currentPos.y, currentPos.z)
                            validatedData.details.raycastHit = true
                            validatedData.details.hitPos = hitPosition
                            validatedData.details.startPos = lastValidPos
                            validatedData.details.endPos = currentPos
                            validatedData.details.hitEntity = hitEntity
                            Log(("^1[NexusGuard Raycast] Noclip/Teleport detected for %s (ID: %d). Ray hit entity %s.^7"):format(playerName, playerId, tostring(hitEntity)), 1)
                        -- else -- Hit occurred close to destination, likely valid.
                        --    Log(("^3[NexusGuard Raycast] Raycast hit near destination for %s. Likely valid.^7"):format(playerName), 3)
                        end
                    -- else -- Raycast didn't hit anything.
                    --    Log(("^3[NexusGuard Raycast] Raycast path clear for %s.^7"):format(playerName), 3)
                    end
                end
            -- elseif moveDistance >= maxSensibleDistance then -- Log large movements but don't raycast.
            --     Log(("^3[NexusGuard Raycast] Skipping raycast for %s due to large distance (%.1fm). Likely admin TP or respawn.^7"):format(playerName, moveDistance), 3)
            end
        -- else -- Log if positions are invalid for raycasting.
        --    validatedData.reason = "Noclip/Teleport raycast validation requires valid current and last positions."
        end
        validatedData.serverValidated = isValid -- Update status based ONLY on the raycast result for now.

    -- Weapon Mod / Clip Size Check Validation
    elseif detectionType == "WeaponModification" or detectionType == "ServerWeaponClipCheck" then
        -- Extract data from the report (clip size, max allowed, weapon hash).
        local reportedClip = tonumber(validatedData.reportedClip) or tonumber(validatedData.details and validatedData.details.reportedClip)
        local maxAllowed = tonumber(validatedData.maxAllowed) or tonumber(validatedData.details and validatedData.details.maxAllowed)
        local weaponHash = validatedData.weaponHash or (validatedData.details and validatedData.details.weaponHash)

        -- Check if reported clip size exceeds the maximum allowed from config (Guideline 24).
        if reportedClip and maxAllowed and reportedClip > maxAllowed then
            isValid = true
            severity = "High" -- Modified weapon stats are high severity.
            validatedData.reason = string.format("Weapon %s clip size %d exceeded max allowed %d", weaponHash or 'Unknown', reportedClip, maxAllowed)
            validatedData.details.weapon = weaponHash
            validatedData.details.reported = reportedClip
            validatedData.details.allowed = maxAllowed
            validatedData.details.base = validatedData.baseClip or (validatedData.details and validatedData.details.baseClip)
        end
         validatedData.serverValidated = isValid

    -- Resource Mismatch Validation
    elseif detectionType == "ResourceMismatch" then
        -- This detection is generated server-side during the resource check, so it's inherently validated.
        isValid = true
        severity = "Critical" -- Resource tampering is critical severity.
        validatedData.reason = "Unauthorized client resources detected (" .. (validatedData.mode or validatedData.details.mode or "unknown mode") .. ")."
        validatedData.details.mismatched = validatedData.mismatched or validatedData.details.mismatched or {}
        validatedData.serverValidated = true -- Mark as server-validated.

    -- Menu Injection / Detection Validation
    elseif detectionType == "MenuInjection" or detectionType == "MenuDetection" then
         -- Server-side validation for menu injection is extremely difficult and unreliable.
         -- Primarily rely on client-side detection heuristics and resource verification.
         severity = "Critical" -- Assume high risk if client reports this.
         validatedData.reason = "Client reported potential menu keybinds or injection indicators."
         -- We cannot reliably validate this server-side based on the event alone.
         isValid = validatedData.clientValidated -- Trust the client's flag for now, but acknowledge lack of server validation.
         validatedData.serverValidated = false -- Explicitly mark as NOT server-validated.

    -- Handle Unknown Detection Types
    else
        Log(("^3Detections Validation Warning: Received unknown detection type '%s' from %s (ID: %d). Client validated: %s^7"):format(
            detectionType, playerName, playerId, tostring(validatedData.clientValidated)
        ), 2)
        severity = "Info" -- Treat unknown types as informational.
        validatedData.reason = "Unknown detection type received by server."
        isValid = validatedData.clientValidated -- Trust client flag if type is unknown.
        validatedData.serverValidated = false -- Cannot validate unknown types server-side.
    end

    -- 3. Apply Penalties if Server-Side Validation Confirmed the Detection
    if isValid then
        ApplyPenalty(playerId, session, detectionType, validatedData, severity)
    else
        -- Log instances where the client reported a detection, but server-side validation failed.
        -- This helps identify potential false positives from client detectors or areas needing better server validation.
        if validatedData.clientValidated then
             Log(("^2Detections Validation Info: Client flagged '%s' for %s (ID: %d), but server-side validation did not confirm. Reason: %s^7"):format(
                 detectionType, playerName, playerId, validatedData.reason or "Validation failed or insufficient data"
             ), 2)
             -- Optional: Apply a very minor trust penalty or log differently for unconfirmed client flags.
             -- ApplyPenalty(playerId, session, detectionType .. "_ClientOnly", validatedData, "Info")
        -- else -- Optional log for cases where neither client nor server validated (e.g., invalid data received)
             -- Log(("^3Detections Validation Info: Detection '%s' for %s (ID: %d) was not validated by client or server.^7"):format(detectionType, playerName, playerId), 3)
        end
    end

    -- Return the server-side validation status.
    return isValid
end


-- #############################################################################
-- ## Specific Server-Side Validation Functions ##
-- #############################################################################

--[[
    Validates position updates received from the client.
    Checks for speed hacks, teleportation, and noclip issues based on server state.
    Calls ApplyPenalty directly if a violation is confirmed.

    @param playerId (number): The server ID of the player.
    @param currentPos (vector3): The position reported by the client.
    @param clientTimestamp (number): The timestamp sent by the client (less reliable).
    @param session (table): The player's session data object.
]]
function Detections.ValidatePositionUpdate(playerId, currentPos, clientTimestamp, session)
    local playerName = GetPlayerName(playerId) or ("Unknown (" .. tostring(playerId) .. ")")

    -- Ensure session and metrics are available.
    if not session or not session.metrics then
        Log(("^1Detections Validation Error: Cannot validate position update for %s (ID: %d) - Session or metrics data missing.^7"):format(playerName, playerId), 1)
        return
    end

    -- Access config tables via the API object for convenience.
    local Config = NexusGuardServer.Config
    local Thresholds = Config.Thresholds or {}

    -- Update player state if not already done in server_main
    if not session.metrics.stateUpdated then
        local ped = GetPlayerPed(playerId)
        if ped and ped ~= -1 then
            -- Update vehicle state
            session.metrics.isInVehicle = GetVehiclePedIsIn(ped, false) ~= 0

            -- Update movement state
            local velocity = GetEntityVelocity(ped)
            session.metrics.isFalling = IsPedFalling(ped)
            session.metrics.isRagdoll = IsPedRagdoll(ped)
            session.metrics.isSwimming = IsPedSwimming(ped)
            session.metrics.verticalVelocity = velocity.z
            session.metrics.isInParachute = IsPedInParachuteFreeFall(ped)
            session.metrics.isGettingUp = IsPedGettingUp(ped)
            session.metrics.isClimbing = IsPedClimbing(ped)
            session.metrics.isVaulting = IsPedVaulting(ped)
            session.metrics.isJumping = IsPedJumping(ped)

            -- Mark state as updated
            session.metrics.stateUpdated = true
        end
    end

    -- Skip checks during the initial spawn grace period.
    if session.metrics.justSpawned then
        -- Still update the position to prevent large jump detection immediately after grace period ends.
        session.metrics.lastServerPosition = currentPos
        session.metrics.lastServerPositionTimestamp = GetGameTimer()
        session.metrics.lastValidPosition = currentPos -- Assume spawn position is valid initially.
        return -- Skip validation during grace period.
    end

    -- Skip checks if player just teleported (e.g., via admin command)
    if session.metrics.justTeleported then
        -- Update positions but don't validate
        session.metrics.lastServerPosition = currentPos
        session.metrics.lastServerPositionTimestamp = GetGameTimer()
        session.metrics.lastValidPosition = currentPos
        return
    end

    -- Load relevant thresholds.
    local serverSpeedThreshold = Thresholds.serverSideSpeedThreshold or 50.0
    local minTimeDiff = Thresholds.minTimeDiffPositionCheck or 450 -- Minimum time between checks (ms).
    local teleportThreshold = Thresholds.teleportThreshold or 100.0 -- Distance in meters that's considered a teleport
    local noclipTolerance = Thresholds.noclipTolerance or 3.0 -- Extra distance tolerance for noclip check.

    -- Perform checks only if enough time has passed since the last check and we have previous position data.
    if session.metrics.lastServerPosition and session.metrics.lastServerPositionTimestamp then
        local lastPos = session.metrics.lastServerPosition
        local lastTimestamp = session.metrics.lastServerPositionTimestamp
        local currentServerTimestamp = GetGameTimer()
        local timeDiffMs = currentServerTimestamp - lastTimestamp

        if timeDiffMs >= minTimeDiff then
            local distance = #(currentPos - lastPos) -- Calculate distance moved.

            -- Check for teleport (large distance change)
            if distance > teleportThreshold then
                -- Check if this is a legitimate teleport (e.g., admin command, script function)
                local isLegitTeleport = false

                -- Check if player has admin permissions (might be a legitimate admin teleport)
                if NexusGuardServer and NexusGuardServer.Permissions and NexusGuardServer.Permissions.IsAdmin then
                    isLegitTeleport = NexusGuardServer.Permissions.IsAdmin(playerId)
                end

                -- If not a legitimate teleport, flag as suspicious
                if not isLegitTeleport then
                    local reason = string.format("Teleport detected: %.2f meters (threshold: %.2f)", distance, teleportThreshold)
                    local details = {
                        distance = distance,
                        threshold = teleportThreshold,
                        fromPos = lastPos,
                        toPos = currentPos,
                        timeDiff = timeDiffMs
                    }

                    -- Apply penalty for teleport detection
                    ApplyPenalty(playerId, session, "ServerTeleportCheck", { reason = reason, details = details, serverValidated = true }, "High")

                    -- Set teleport grace period to avoid multiple detections for the same teleport
                    session.metrics.justTeleported = true
                    local teleportGracePeriod = Thresholds.teleportGracePeriod or 5 -- Default 5 seconds
                    SetTimeout(teleportGracePeriod * 1000, function()
                        if session and session.metrics then
                            session.metrics.justTeleported = false
                        end
                    end)
                end

                -- Update position data even for teleports
                session.metrics.lastServerPosition = currentPos
                session.metrics.lastServerPositionTimestamp = currentServerTimestamp
                return
            end

            -- Calculate speed in m/s
            local speed = 0.0
            if timeDiffMs > 0 then
                speed = distance / (timeDiffMs / 1000.0)
            end

            -- Adjust speed threshold based on player state.
            local effectiveSpeedThreshold = serverSpeedThreshold
            local reasonSuffix = ""

            -- Check for special movement states that justify higher speeds
            if session.metrics.isFalling or session.metrics.isRagdoll or session.metrics.isInParachute or
               (session.metrics.verticalVelocity and session.metrics.verticalVelocity < -10.0) or
               session.metrics.isGettingUp or session.metrics.isClimbing or session.metrics.isVaulting or
               session.metrics.isJumping then
                effectiveSpeedThreshold = serverSpeedThreshold * 2.5
                reasonSuffix = " (Adjusted for movement state)"
            elseif session.metrics.isInVehicle then
                -- Get vehicle model and adjust threshold based on vehicle type
                local ped = GetPlayerPed(playerId)
                local vehicle = GetVehiclePedIsIn(ped, false)
                local vehicleClass = GetVehicleClass(vehicle)

                -- Higher threshold for super cars, planes, helicopters
                if vehicleClass == 7 or vehicleClass == 15 or vehicleClass == 16 then
                    effectiveSpeedThreshold = serverSpeedThreshold * 2.0
                else
                    effectiveSpeedThreshold = serverSpeedThreshold * 1.3
                end
                reasonSuffix = " (Adjusted for vehicle class " .. vehicleClass .. ")"
            end

            -- Check if calculated speed exceeds the effective threshold.
            if speed > effectiveSpeedThreshold then
                local reason = string.format("Calculated speed %.2f m/s exceeded threshold %.2f m/s%s", speed, effectiveSpeedThreshold, reasonSuffix)
                local details = {
                    speed = speed,
                    threshold = effectiveSpeedThreshold,
                    distance = distance,
                    timeDiff = timeDiffMs,
                    state = {
                        falling = session.metrics.isFalling,
                        ragdoll = session.metrics.isRagdoll,
                        parachute = session.metrics.isInParachute,
                        inVehicle = session.metrics.isInVehicle,
                        vertVel = session.metrics.verticalVelocity,
                        swimming = session.metrics.isSwimming,
                        climbing = session.metrics.isClimbing,
                        vaulting = session.metrics.isVaulting,
                        jumping = session.metrics.isJumping,
                        gettingUp = session.metrics.isGettingUp
                    }
                }

                -- Store movement sample for pattern analysis
                if not session.metrics.movementSamples then session.metrics.movementSamples = {} end
                table.insert(session.metrics.movementSamples, {
                    timestamp = os.time(),
                    speed = speed,
                    distance = distance,
                    timeDiff = timeDiffMs,
                    position = currentPos,
                    state = details.state
                })

                -- Limit history size
                if #session.metrics.movementSamples > 20 then
                    table.remove(session.metrics.movementSamples, 1)
                end

                -- Apply penalty for speed hack detection
                ApplyPenalty(playerId, session, "ServerSpeedCheck", { reason = reason, details = details, serverValidated = true }, "High")
            else
                -- Perform noclip detection using raycasting if enabled
                if Thresholds.enableNoclipDetection and session.metrics.lastValidPosition then
                    local lastValidPos = session.metrics.lastValidPosition
                    local moveDistance = #(currentPos - lastValidPos)

                    -- Only check for noclip if the distance is significant but not too large
                    if moveDistance > noclipTolerance and moveDistance < teleportThreshold / 2 then
                        local sourcePed = GetPlayerPed(playerId)
                        if sourcePed and sourcePed ~= -1 then
                            -- Perform raycast to check if there are obstacles between positions
                            local rayStart = vector3(lastValidPos.x, lastValidPos.y, lastValidPos.z + 0.5) -- Offset slightly above ground
                            local rayEnd = vector3(currentPos.x, currentPos.y, currentPos.z + 0.5)

                            -- Use async raycast with a small wait (not ideal but better than sync)
                            local rayHandle = StartShapeTestRay(rayStart.x, rayStart.y, rayStart.z, rayEnd.x, rayEnd.y, rayEnd.z, 1, sourcePed, 0)
                            Citizen.Wait(50) -- Small wait for raycast to complete
                            local retval, hit, endCoords, surfaceNormal, entityHit = GetShapeTestResult(rayHandle)

                            if hit == 1 then -- If raycast hit something
                                local hitPos = vector3(endCoords.x, endCoords.y, endCoords.z)
                                local distToHit = #(hitPos - rayStart)
                                local targetDist = #(rayEnd - rayStart)

                                -- If hit occurred significantly before destination, potential noclip
                                if distToHit < (targetDist - noclipTolerance) then
                                    local reason = string.format("Potential noclip detected: Ray hit obstacle at %.1f meters, but player moved %.1f meters", distToHit, targetDist)
                                    local details = {
                                        raycastHit = true,
                                        hitPos = hitPos,
                                        startPos = lastValidPos,
                                        endPos = currentPos,
                                        distToHit = distToHit,
                                        totalDist = targetDist,
                                        entityHit = entityHit
                                    }

                                    -- Apply penalty for noclip detection
                                    ApplyPenalty(playerId, session, "ServerNoclipCheck", { reason = reason, details = details, serverValidated = true }, "High")
                                end
                            end
                        end
                    end
                end

                -- If all checks passed, update last valid position
                session.metrics.lastValidPosition = currentPos
            end
        end
    else
        -- Initialize last valid position on the very first update received
        session.metrics.lastValidPosition = currentPos
    end

    -- Reset state updated flag for next check
    session.metrics.stateUpdated = false

    -- Always update the last known position and timestamp for the next check
    session.metrics.lastServerPosition = currentPos
    session.metrics.lastServerPositionTimestamp = GetGameTimer()
end

--[[
    Validates health/armor updates received from the client.
    Checks for abnormal regeneration, armor values, and godmode patterns based on server state.
    Calls ApplyPenalty directly if a violation is confirmed.

    @param playerId (number): The server ID of the player.
    @param currentHealth (number): The health value reported by the client.
    @param currentArmor (number): The armor value reported by the client.
    @param clientTimestamp (number): The timestamp sent by the client (not used).
    @param session (table): The player's session data object.
]]
function Detections.ValidateHealthUpdate(playerId, currentHealth, currentArmor, clientTimestamp, session)
    local playerName = GetPlayerName(playerId) or ("Unknown (" .. tostring(playerId) .. ")")
    -- Ensure session and metrics are available.
    if not session or not session.metrics then
        Log(("^1Detections Validation Error: Cannot validate health update for %s (ID: %d) - Session or metrics data missing.^7"):format(playerName, playerId), 1)
        return
    end

    -- Access config tables via the API object for convenience.
    local Config = NexusGuardServer.Config
    local Thresholds = Config.Thresholds or {}

    -- Skip checks during the initial spawn grace period.
    if session.metrics.justSpawned then
        -- Still update the health/armor to prevent false detections after grace period ends.
        session.metrics.lastServerHealth = currentHealth
        session.metrics.lastServerArmor = currentArmor
        session.metrics.lastServerHealthTimestamp = GetGameTimer()
        return -- Skip validation during grace period.
    end

    -- Load relevant thresholds.
    local serverHealthRegenThreshold = Thresholds.serverSideRegenThreshold or 3.0 -- Max HP regen per second.
    local serverArmorMax = Thresholds.serverSideArmorThreshold or 105.0 -- Max allowed armor value + tolerance.
    local minHealthDamageThreshold = Thresholds.minHealthDamageThreshold or 5.0 -- Minimum health damage to consider for godmode detection
    local godModeDetectionWindow = Thresholds.godModeDetectionWindow or 60 -- Time window in seconds for godmode pattern detection

    -- Check for suspicious health regeneration.
    if session.metrics.lastServerHealth and session.metrics.lastServerHealthTimestamp then
        local lastHealth = session.metrics.lastServerHealth
        local lastTimestamp = session.metrics.lastServerHealthTimestamp
        local currentServerTimestamp = GetGameTimer()
        local timeDiffMs = currentServerTimestamp - lastTimestamp

        -- Store health history for pattern analysis
        if not session.metrics.healthHistory then session.metrics.healthHistory = {} end

        -- Add current health reading to history
        table.insert(session.metrics.healthHistory, {
            health = currentHealth,
            armor = currentArmor,
            timestamp = os.time(),
            serverTimestamp = currentServerTimestamp,
            change = currentHealth - lastHealth
        })

        -- Limit history size
        if #session.metrics.healthHistory > 20 then
            table.remove(session.metrics.healthHistory, 1)
        end

        -- Check for health increase (regeneration)
        if currentHealth > lastHealth and timeDiffMs > 500 then
            local healthIncrease = currentHealth - lastHealth
            local regenRate = 0.0
            if timeDiffMs > 0 then regenRate = healthIncrease / (timeDiffMs / 1000.0) end -- Regen rate in HP/sec.

            -- Flag if regen rate exceeds threshold
            if regenRate > serverHealthRegenThreshold then
                local reason = string.format("Health regeneration rate %.2f HP/s (increase %.1f HP) exceeded threshold %.2f HP/s",
                    regenRate, healthIncrease, serverHealthRegenThreshold)
                local details = {
                    increase = healthIncrease,
                    rate = regenRate,
                    threshold = serverHealthRegenThreshold,
                    timeDiff = timeDiffMs,
                    lastHealth = lastHealth,
                    currentHealth = currentHealth
                }

                -- Apply penalty for health regeneration violation
                ApplyPenalty(playerId, session, "ServerHealthRegenCheck", { reason = reason, details = details, serverValidated = true }, "Medium")
            end
        end

        -- Check for godmode pattern (no health decrease despite taking damage)
        -- This requires additional data from damage events which would ideally be tracked separately
        -- For now, we'll use a simplified approach based on health history
        if #session.metrics.healthHistory >= 3 then
            local godModePattern = DetectGodModePattern(session.metrics.healthHistory, godModeDetectionWindow, minHealthDamageThreshold)

            if godModePattern then
                local reason = "Potential god mode detected: " .. godModePattern.reason
                local details = {
                    pattern = godModePattern.pattern,
                    samples = godModePattern.samples,
                    timeWindow = godModeDetectionWindow
                }

                -- Apply penalty for godmode detection
                ApplyPenalty(playerId, session, "ServerGodModeCheck", { reason = reason, details = details, serverValidated = true }, "High")
            end
        end
    end

    -- Check if current armor exceeds the configured maximum threshold.
    if currentArmor > serverArmorMax then
        local reason = string.format("Armor value %.1f exceeded maximum allowed %.1f", currentArmor, serverArmorMax)
        local details = {
            armor = currentArmor,
            threshold = serverArmorMax
        }

        -- Apply penalty for armor violation
        ApplyPenalty(playerId, session, "ServerArmorCheck", { reason = reason, details = details, serverValidated = true }, "Medium")
    end

    -- Update the last known health, armor, and timestamp in the session metrics.
    session.metrics.lastServerHealth = currentHealth
    session.metrics.lastServerArmor = currentArmor
    session.metrics.lastServerHealthTimestamp = GetGameTimer()
end

--[[
    Analyzes health history to detect godmode patterns.
    Looks for patterns like no health decrease despite taking damage.

    @param healthHistory (table): Array of health history entries.
    @param timeWindow (number): Time window in seconds to analyze.
    @param minDamageThreshold (number): Minimum health damage to consider.
    @return (table|nil): Detection details if godmode pattern found, nil otherwise.
]]
function DetectGodModePattern(healthHistory, timeWindow, minDamageThreshold)
    if not healthHistory or #healthHistory < 3 then return nil end

    local currentTime = os.time()
    local recentHistory = {}

    -- Filter to recent entries within the time window
    for _, entry in ipairs(healthHistory) do
        if currentTime - entry.timestamp <= timeWindow then
            table.insert(recentHistory, entry)
        end
    end

    if #recentHistory < 3 then return nil end

    -- Look for suspicious patterns
    local noHealthDecrease = true
    local minHealth = recentHistory[1].health
    local maxHealth = recentHistory[1].health

    for _, entry in ipairs(recentHistory) do
        minHealth = math.min(minHealth, entry.health)
        maxHealth = math.max(maxHealth, entry.health)

        -- If we see any significant health decrease, not godmode
        if entry.change and entry.change < -minDamageThreshold then
            noHealthDecrease = false
            break
        end
    end

    -- If health never decreased significantly but had variation (indicating potential damage events)
    -- and we have enough samples, flag as potential godmode
    if noHealthDecrease and (maxHealth - minHealth) < minDamageThreshold and #recentHistory >= 5 then
        return {
            reason = string.format("No significant health decrease over %d seconds despite health variations", timeWindow),
            pattern = "no_decrease",
            samples = #recentHistory
        }
    end

    -- Check for perfect health maintenance (always exactly 100 or 200)
    local perfectHealth = true
    local healthValue = recentHistory[1].health

    for _, entry in ipairs(recentHistory) do
        if entry.health ~= healthValue then
            perfectHealth = false
            break
        end
    end

    if perfectHealth and #recentHistory >= 5 and (healthValue == 100 or healthValue == 200) then
        return {
            reason = string.format("Health maintained at exactly %.1f for %d seconds", healthValue, timeWindow),
            pattern = "perfect_health",
            samples = #recentHistory
        }
    end

    return nil
end


-- #############################################################################
-- ## History and Pattern Analysis ##
-- #############################################################################

--[[
    Add a detection to the player's history for pattern analysis.
    @param playerId (number): The server ID of the player.
    @param detectionType (string): The type of detection.
    @param details (table): Additional details about the detection.
    @param severity (string): The severity level of the detection.
    @param confidence (number): The confidence level of the detection (0.0 to 1.0).
]]
function Detections.AddToHistory(playerId, detectionType, details, severity, confidence)
    -- Initialize player history if it doesn't exist
    if not Detections.history[playerId] then
        Detections.history[playerId] = {}
    end

    -- Add the detection to history
    table.insert(Detections.history[playerId], {
        type = detectionType,
        details = details,
        severity = severity,
        confidence = confidence,
        timestamp = os.time()
    })

    -- Limit history size to prevent memory bloat
    while #Detections.history[playerId] > Detections.defaultThresholds.maxHistorySize do
        table.remove(Detections.history[playerId], 1)
    end

    -- Update pattern analysis
    Detections.AnalyzePatterns(playerId)
end

--[[
    Analyze detection patterns for a player.
    @param playerId (number): The server ID of the player.
    @return (table): A table of detected patterns.
]]
function Detections.AnalyzePatterns(playerId)
    if not Detections.history[playerId] or #Detections.history[playerId] < 2 then
        return {}
    end

    local patterns = {}
    local currentTime = os.time()
    local timeWindow = Detections.defaultThresholds.patternTimeWindow
    local threshold = Detections.defaultThresholds.patternDetectionThreshold

    -- Count detections by type within the time window
    local typeCounts = {}
    for _, detection in ipairs(Detections.history[playerId]) do
        if currentTime - detection.timestamp <= timeWindow then
            typeCounts[detection.type] = (typeCounts[detection.type] or 0) + 1
        end
    end

    -- Identify patterns based on frequency
    for detectionType, count in pairs(typeCounts) do
        if count >= threshold then
            table.insert(patterns, {
                type = detectionType,
                count = count,
                timeWindow = timeWindow
            })
        end
    end

    -- Store patterns for this player
    Detections.patterns[playerId] = patterns

    return patterns
end

--[[
    Calculate detection severity based on multiple factors.
    @param playerId (number): The server ID of the player.
    @param detectionType (string): The type of detection.
    @param baseConfidence (number): The base confidence level (0.0 to 1.0).
    @param session (table): The player's session data.
    @return (string, number): The severity level and adjusted confidence.
]]
function Detections.CalculateSeverity(playerId, detectionType, baseConfidence, session)
    -- Default to medium severity if we can't determine better
    local severity = Detections.severityLevels.MEDIUM
    local confidence = baseConfidence or Detections.confidenceLevels.MEDIUM

    -- Get config severity scores
    local Config = NexusGuardServer.Config
    local severityScore = (Config.SeverityScores and Config.SeverityScores[detectionType]) or
                          (Config.SeverityScores and Config.SeverityScores.default) or 5

    -- Adjust based on detection history
    local historyFactor = 1.0
    if Detections.history[playerId] then
        local recentDetections = 0
        local currentTime = os.time()

        -- Count recent detections of the same type
        for _, detection in ipairs(Detections.history[playerId]) do
            if detection.type == detectionType and currentTime - detection.timestamp <= 300 then
                recentDetections = recentDetections + 1
            end
        end

        -- Increase confidence based on repeated detections
        if recentDetections > 0 then
            historyFactor = math.min(2.0, 1.0 + (recentDetections * 0.2))
        end
    end

    -- Adjust confidence based on history
    confidence = math.min(Detections.confidenceLevels.CERTAIN, confidence * historyFactor)

    -- Determine severity based on confidence and severity score
    if confidence >= Detections.confidenceLevels.HIGH then
        if severityScore >= 15 then
            severity = Detections.severityLevels.CRITICAL
        else
            severity = Detections.severityLevels.HIGH
        end
    elseif confidence >= Detections.confidenceLevels.MEDIUM then
        if severityScore >= 10 then
            severity = Detections.severityLevels.HIGH
        else
            severity = Detections.severityLevels.MEDIUM
        end
    elseif confidence >= Detections.confidenceLevels.LOW then
        severity = Detections.severityLevels.LOW
    else
        severity = Detections.severityLevels.INFO
    end

    -- Consider player trust score if available
    if session and session.metrics and session.metrics.trustScore then
        local trustScore = session.metrics.trustScore

        -- Lower trust score increases severity
        if trustScore < 50 and severity ~= Detections.severityLevels.CRITICAL then
            -- Escalate severity by one level if trust is low
            if severity == Detections.severityLevels.HIGH then
                severity = Detections.severityLevels.CRITICAL
            elseif severity == Detections.severityLevels.MEDIUM then
                severity = Detections.severityLevels.HIGH
            elseif severity == Detections.severityLevels.LOW then
                severity = Detections.severityLevels.MEDIUM
            end
        end
    end

    return severity, confidence
end

--[[
    Determine the appropriate response based on detection severity and player history.
    @param playerId (number): The server ID of the player.
    @param detectionType (string): The type of detection.
    @param severity (string): The severity level of the detection.
    @param session (table): The player's session data.
    @return (string): The response action to take.
]]
function Detections.DetermineResponse(playerId, detectionType, severity, session)
    -- Default response is to log only
    local response = "log"

    -- Get config action settings
    local Config = NexusGuardServer.Config
    local Actions = Config.Actions or {}

    -- Get trust score if available
    local trustScore = (session and session.metrics and session.metrics.trustScore) or 100

    -- Determine response based on severity and trust score
    if severity == Detections.severityLevels.CRITICAL then
        if Actions.banOnConfirmed then
            response = "ban"
        else
            response = "kick"
        end
    elseif severity == Detections.severityLevels.HIGH then
        if trustScore <= 50 and Actions.banOnConfirmed then
            response = "ban"
        elseif Actions.kickOnSuspicion then
            response = "kick"
        else
            response = "warn"
        end
    elseif severity == Detections.severityLevels.MEDIUM then
        if trustScore <= 30 and Actions.kickOnSuspicion then
            response = "kick"
        else
            response = "warn"
        end
    elseif severity == Detections.severityLevels.LOW then
        response = "warn"
    else
        response = "log"
    end

    -- Check for specific action config for this detection type
    local typeActions = Actions[detectionType]
    if typeActions then
        if typeActions.alwaysBan then
            response = "ban"
        elseif typeActions.alwaysKick then
            response = "kick"
        elseif typeActions.neverBan and response == "ban" then
            response = "kick"
        elseif typeActions.neverKick and (response == "kick" or response == "ban") then
            response = "warn"
        end
    end

    return response
end

--[[
    Cleanup old detection data to prevent memory bloat.
]]
function Detections.Cleanup()
    local currentTime = GetGameTimer()

    -- Only run cleanup at the specified interval
    if currentTime - Detections.defaultThresholds.lastCleanup < Detections.defaultThresholds.cleanupInterval then
        return
    end

    Detections.defaultThresholds.lastCleanup = currentTime
    local connectedPlayers = GetPlayers()
    local connectedIds = {}

    -- Create a lookup table of connected player IDs
    for _, id in ipairs(connectedPlayers) do
        connectedIds[tonumber(id)] = true
    end

    -- Remove data for disconnected players
    for playerId, _ in pairs(Detections.history) do
        if not connectedIds[playerId] then
            Detections.history[playerId] = nil
            Detections.patterns[playerId] = nil
            Log(string.format("^3[Detections]^7 Cleaned up detection data for disconnected player ID: %d", playerId), 3)
        end
    end
end

--[[
    Get detection history for a player.
    @param playerId (number): The server ID of the player.
    @return (table): The player's detection history.
]]
function Detections.GetPlayerHistory(playerId)
    return Detections.history[playerId] or {}
end

--[[
    Get detected patterns for a player.
    @param playerId (number): The server ID of the player.
    @return (table): The player's detected patterns.
]]
function Detections.GetPlayerPatterns(playerId)
    return Detections.patterns[playerId] or {}
end

-- Modify the Process function to use the new features
local originalProcess = Detections.Process
Detections.Process = function(playerId, detectionType, detectionData, session)
    -- Run cleanup periodically
    Detections.Cleanup()

    -- Call the original Process function
    local isValid = originalProcess(playerId, detectionType, detectionData, session)

    -- If the detection was valid, add it to history and analyze patterns
    if isValid then
        -- Determine confidence level based on validation
        local confidence = detectionData.serverValidated and Detections.confidenceLevels.HIGH or
                          (detectionData.clientValidated and Detections.confidenceLevels.MEDIUM or
                           Detections.confidenceLevels.LOW)

        -- Calculate severity with context awareness
        local severity, adjustedConfidence = Detections.CalculateSeverity(playerId, detectionType, confidence, session)

        -- Add to history for pattern analysis
        Detections.AddToHistory(playerId, detectionType, detectionData.details, severity, adjustedConfidence)

        -- Determine appropriate response
        local response = Detections.DetermineResponse(playerId, detectionType, severity, session)

        -- Log the determined response
        Log(string.format("^3[Detections]^7 Response for %s (ID: %d), Type: %s, Severity: %s, Confidence: %.2f - Action: %s",
            GetPlayerName(playerId) or "Unknown", playerId, detectionType, severity, adjustedConfidence, response), 2)
    end

    return isValid
end

-- Export the Detections table.
return Detections
