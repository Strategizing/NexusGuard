--[[
    NexusGuard Server-Side Detection Processing Module (server/modules/detections.lua)

    Purpose:
    - Central logic for processing detection reports received from clients or generated by server-side checks.
    - Validates the received data against server-side logic and configuration thresholds.
    - Determines the severity of the detection.
    - Applies penalties based on severity and trust score, including logging, trust score reduction,
      Discord notifications, and potentially kicks or bans.

    Dependencies:
    - Global `NexusGuardServer` API table (for Config, Utils, Bans, Discord)
    - `ox_lib` resource (for `lib.json`)

    Usage:
    - Required by `globals.lua` and exposed via the `NexusGuardServer.Detections` API table.
    - The `Process` function is the main entry point, called by event handlers in `server_main.lua`
      or potentially other server-side checks.
]]
local Detections = {}

-- Attempt to get the NexusGuard Server API from globals.lua. Use pcall for safety.
local successAPI, NexusGuardServer = pcall(function() return exports['NexusGuard']:GetNexusGuardServerAPI() end)
if not successAPI or not NexusGuardServer then
    print("^1[NexusGuard Detections] CRITICAL: Failed to get NexusGuardServer API. Detections module will not function.^7")
    -- Create dummy API to prevent immediate errors, although functionality will be broken.
    NexusGuardServer = NexusGuardServer or {
        Config = { Thresholds = {}, Severity = {}, Actions = {} },
        Utils = { Log = function(...) print("[NexusGuard Detections Fallback Log]", ...) end },
        Bans = {}, Discord = {}
    }
end

-- Local alias for the logging function.
local Log = NexusGuardServer.Utils.Log

--[[
    Validates the basic structure of incoming detection data.
    Ensures it's a table and contains expected (even if nil) fields.

    @param detectionData (any): The raw data received with the detection report.
    @return (table): A validated table structure, potentially wrapping non-table input.
]]
local function ValidateDetectionData(detectionData)
    if type(detectionData) ~= "table" then
        Log(("^1Detections Validation Warning: Received non-table detection data (%s). Wrapping it.^7"):format(type(detectionData)), 1)
        -- Wrap non-table data for consistency, assume client validation failed.
        return { value = detectionData, details = {}, clientValidated = false }
    end
    -- Ensure essential fields exist, defaulting if necessary.
    detectionData.value = detectionData.value -- The primary value reported (e.g., speed, health).
    detectionData.details = detectionData.details or {} -- Additional contextual details.
    detectionData.clientValidated = detectionData.clientValidated or false -- Flag indicating if the client-side detector triggered this report.
    return detectionData
end

--[[
    Applies penalties based on a validated detection.
    - Logs the detection event.
    - Reduces the player's trust score based on severity.
    - Stores the detection event in the player's session metrics.
    - Sends a Discord notification (if configured).
    - Executes kick/ban actions based on trust score thresholds defined in config.

    @param playerId (number): The server ID of the player.
    @param session (table): The player's session data object.
    @param detectionType (string): The type of detection.
    @param validatedData (table): The validated detection data, including server-side validation results/reason.
    @param severity (string): The determined severity ("Low", "Medium", "High", "Critical", "Info").
]]
local function ApplyPenalty(playerId, session, detectionType, validatedData, severity)
    local playerName = GetPlayerName(playerId) or ("Unknown (" .. tostring(playerId) .. ")")
    local reason = validatedData.reason or "No specific reason provided."
    local details = validatedData.details or {}
    -- Determine trust score impact based on severity config, with defaults.
    local trustImpact = (NexusGuardServer.Config.Severity and NexusGuardServer.Config.Severity[detectionType]) or
                        (NexusGuardServer.Config.Severity and NexusGuardServer.Config.Severity.default) or 5

    -- Ensure JSON encoding is safe for logging details.
    local detailsJson = "error encoding"
    if lib and lib.json then
        local encSuccess, encResult = pcall(lib.json.encode, details)
        if encSuccess then detailsJson = encResult end
    end

    -- Log the confirmed detection event.
    Log(("^1[NexusGuard Detection Confirmed]^7 Player: %s (ID: %d) | Type: %s | Severity: %s | Reason: %s | Details: %s^7"):format(
        playerName, playerId, detectionType, severity, reason, detailsJson
    ), 1)

    -- Update Trust Score in session metrics.
    if session and session.metrics then
        local oldTrust = session.metrics.trustScore or 100
        session.metrics.trustScore = math.max(0, oldTrust - trustImpact) -- Clamp score at 0.
        Log(("^3[NexusGuard Trust]^7 Trust score for %s (ID: %d) reduced by %d due to %s. New score: %.1f^7"):format(
            playerName, playerId, trustImpact, detectionType, session.metrics.trustScore
        ), 2)

        -- Store the detection event details within the session metrics.
        if not session.metrics.detections then session.metrics.detections = {} end
        table.insert(session.metrics.detections, {
            type = detectionType,
            reason = reason,
            details = details, -- Store original table, not JSON
            severity = severity,
            trustImpact = trustImpact,
            timestamp = os.time()
        })
        -- Also store in database if configured
        if NexusGuardServer.Database and NexusGuardServer.Database.StoreDetection then
            NexusGuardServer.Database.StoreDetection(playerId, detectionType, details) -- Pass original details table
        end
    else
         Log(("^1Detections Penalty Warning: Cannot apply trust score penalty or store detection for %s (ID: %d) - session or metrics missing.^7"):format(playerName, playerId), 1)
    end

    -- Send Discord Notification via Discord module API.
    if NexusGuardServer.Discord and NexusGuardServer.Discord.Send then
        local discordMsg = string.format(
            "**Player:** %s (`%d`)\n**Detection:** %s\n**Severity:** %s\n**Reason:** %s\n**Details:** `%s`\n**Trust Score:** %.1f (`-%d`)",
            playerName, playerId, detectionType, severity, reason, detailsJson,
            session and session.metrics and session.metrics.trustScore or -1.0, -- Show current score or -1 if unavailable
            trustImpact
        )
        -- Determine the correct webhook URL (category-specific or general).
        local webhook = NexusGuardServer.Config.Discord and NexusGuardServer.Config.Discord.webhooks and NexusGuardServer.Config.Discord.webhooks.detections
        NexusGuardServer.Discord.Send("detections", "Suspicious Activity Detected", discordMsg, webhook)
    end

    -- Execute Actions (Ban/Kick) based on trust score thresholds defined in config.
    -- TODO: Implement more sophisticated progressive banning logic (e.g., based on frequency/severity of recent detections).
    local actionConfig = (NexusGuardServer.Config.Actions and NexusGuardServer.Config.Actions[detectionType]) or
                         (NexusGuardServer.Config.Actions and NexusGuardServer.Config.Actions.default) or
                         { kickThreshold = 50, banThreshold = 20 } -- Default thresholds if not configured.
    local currentTrust = (session and session.metrics and session.metrics.trustScore) or 100.0 -- Default to 100 if unavailable.

    -- Check Ban Threshold
    if currentTrust <= actionConfig.banThreshold then
        Log(("^1[NexusGuard Action]^7 Trust score (%.1f) reached ban threshold (<= %.1f) for detection '%s'. Banning %s (ID: %d).^7"):format(
            currentTrust, actionConfig.banThreshold, detectionType, playerName, playerId
        ), 1)
        -- Execute ban via Bans module API.
        if NexusGuardServer.Bans and NexusGuardServer.Bans.Execute then
            local banReason = ("Automatic ban: Triggered %s (Trust Score: %.1f)"):format(detectionType, currentTrust)
            NexusGuardServer.Bans.Execute(playerId, banReason, "NexusGuard System") -- Default to permanent ban.
        else
             Log("^1Detections Action Error: Bans.Execute function missing from API. Cannot ban player. Kicking as fallback.^7", 1)
             DropPlayer(playerId, "Kicked by Anti-Cheat (System Error: Ban Function Missing)")
        end
    -- Check Kick Threshold (only if not banned)
    elseif currentTrust <= actionConfig.kickThreshold then
        Log(("^1[NexusGuard Action]^7 Trust score (%.1f) reached kick threshold (<= %.1f) for detection '%s'. Kicking %s (ID: %d).^7"):format(
            currentTrust, actionConfig.kickThreshold, detectionType, playerName, playerId
        ), 1)
        local kickReason = ("Kicked by Anti-Cheat: Triggered %s (Trust Score: %.1f)"):format(detectionType, currentTrust)
        DropPlayer(playerId, kickReason)
    end
end

--[[
    Main processing function for detection reports.
    Validates incoming data, performs server-side checks, determines severity, and applies penalties.

    @param playerId (number): The server ID of the player associated with the detection.
    @param detectionType (string): A string identifying the type of detection (e.g., "SpeedHack", "GodMode", "ServerSpeedCheck").
    @param detectionData (table): A table containing details reported by the client detector or server-side check.
                                  Expected fields vary by detection type but often include `value`, `details`, `clientValidated`.
    @param session (table): The player's session data object, containing metrics and state.
    @return (boolean): True if the detection was validated server-side, false otherwise.
]]
function Detections.Process(playerId, detectionType, detectionData, session)
    -- Ensure essential components are loaded.
    if not NexusGuardServer or not Log then print("^1[NexusGuard Detections] CRITICAL: NexusGuardServer API or Log function not available. Cannot process detection.^7"); return false end

    local playerName = GetPlayerName(playerId) or ("Unknown (" .. tostring(playerId) .. ")")
    Log(("^3Detections: Processing report for player %s (ID: %d), Type: %s^7"):format(playerName, playerId, detectionType), 3)

    -- 1. Validate Input Data Structure: Ensure detectionData is a table with expected base fields.
    local validatedData = ValidateDetectionData(detectionData)
    validatedData.serverValidated = false -- Initialize server validation status for this run.
    validatedData.reason = validatedData.reason or "Initial report received" -- Default reason if none provided.

    -- 2. Perform Server-Side Validation: Check the data against server logic and config.
    local isValid = false          -- Flag indicating if server-side checks confirm the detection.
    local severity = "Low"         -- Default severity, adjusted based on validation.

    -- Ensure session and metrics are available, as they are crucial for most validations.
    if not session or not session.metrics then
        Log(("^1Detections Validation Error: Cannot validate detection '%s' for %s (ID: %d) - Session or metrics data missing.^7"):format(detectionType, playerName, playerId), 1)
        -- Cannot proceed with validation without session data.
        return false
    end

    -- Access config tables via the API object for convenience.
    local Config = NexusGuardServer.Config
    local Thresholds = Config.Thresholds or {}
    local Features = Config.Features or {}

    -- --- Specific Detection Type Validation Logic ---
    -- Use 'elseif' structure to handle different detection types.

    -- Speed Hack / Server Speed Check Validation
    if detectionType == "SpeedHack" or detectionType == "ServerSpeedCheck" then
        -- Extract speed value (might come from client 'value' or server 'calculatedSpeed').
        local speed = tonumber(validatedData.value) or tonumber(validatedData.calculatedSpeed) or tonumber(validatedData.details and validatedData.details.speed)
        if speed then
            local baseThreshold = Thresholds.serverSideSpeedThreshold or 50.0 -- Base speed limit (m/s).
            local effectiveThreshold = baseThreshold
            local reasonSuffix = ""

            -- Adjust threshold based on player state stored in session metrics (Guideline 26, 38).
            if session.metrics.isFalling or session.metrics.isRagdoll or session.metrics.isInParachute or (session.metrics.verticalVelocity and session.metrics.verticalVelocity < -10.0) then
                effectiveThreshold = baseThreshold * 2.5 -- Allow significantly higher speed if falling/ragdolling/parachuting.
                reasonSuffix = " (Adjusted for falling/ragdoll/parachute)"
            elseif session.metrics.isInVehicle then
                effectiveThreshold = baseThreshold * 1.3 -- Allow slightly higher speed in vehicles.
                reasonSuffix = " (Adjusted for vehicle)"
            end

            -- Check if calculated speed exceeds the adjusted threshold.
            if speed > effectiveThreshold then
                isValid = true
                severity = "High" -- Speeding is usually high severity.
                validatedData.reason = string.format("Calculated speed %.2f m/s exceeded threshold %.2f m/s%s", speed, effectiveThreshold, reasonSuffix)
                -- Store relevant details for logging/review.
                validatedData.details.speed = speed
                validatedData.details.threshold = effectiveThreshold
                validatedData.details.state = { falling=session.metrics.isFalling, ragdoll=session.metrics.isRagdoll, parachute=session.metrics.isInParachute, inVehicle=session.metrics.isInVehicle, vertVel=session.metrics.verticalVelocity }
            end
        else
            -- If speed value is missing or invalid.
            validatedData.reason = "Invalid or missing speed value in detection data."
            severity = "Info" -- Treat as informational, not a confirmed cheat.
        end
        validatedData.serverValidated = isValid -- Update server validation status.

    -- God Mode / Health Regeneration Check Validation
    elseif detectionType == "GodMode" or detectionType == "ServerHealthRegenCheck" then
        -- Extract data specific to the server-side health regen check.
        local increase = tonumber(validatedData.increase)
        local rate = tonumber(validatedData.rate)
        local regenThreshold = Thresholds.serverSideRegenThreshold or 3.0 -- Max allowed HP/sec regen.

        -- Validate based on the server-side regen check logic (Guideline 29).
        -- Requires significant increase AND rate exceeding threshold.
        if rate and increase and rate > regenThreshold and increase > 5.0 then
             isValid = true
             severity = "Medium" -- Suspicious regen is medium severity.
             validatedData.reason = string.format("Health regeneration rate %.2f HP/s (increase %.1f HP) exceeded threshold %.2f HP/s", rate, increase, regenThreshold)
             validatedData.details.rate = rate
             validatedData.details.increase = increase
             validatedData.details.threshold = regenThreshold
             validatedData.details.timeDiff = validatedData.timeDiff
        else
            -- TODO: Add server-side validation logic for "GodMode" reports from client.
            -- This might involve checking recent damage events vs health changes stored in session.metrics.healthHistory.
            -- For now, if it's just "GodMode" without regen data, we don't have server validation.
            -- validatedData.reason = "GodMode validation requires health history analysis (Not Implemented)."
        end
         validatedData.serverValidated = isValid

    -- Server-Side Armor Check Validation
    elseif detectionType == "ServerArmorCheck" then
        local armor = tonumber(validatedData.armor)
        local maxArmor = Thresholds.serverSideArmorThreshold or 105.0 -- Max allowed armor + tolerance.
        -- Check if reported armor exceeds the configured maximum (Guideline 25).
        if armor and armor > maxArmor then
            isValid = true
            severity = "Medium" -- High armor is suspicious.
            validatedData.reason = string.format("Armor value %.1f exceeded maximum allowed %.1f", armor, maxArmor)
            validatedData.details.armor = armor
            validatedData.details.threshold = maxArmor
        end
        validatedData.serverValidated = isValid

    -- Teleport / Noclip Validation (Includes basic distance and experimental raycast)
    elseif detectionType == "Teleport" or detectionType == "Noclip" or detectionType == "ServerNoclipCheck" then
        -- Basic distance check (less reliable)
        local distance = tonumber(validatedData.distance)
        local timeDiff = tonumber(validatedData.timeDiff)
        if distance and timeDiff then
            -- This check is prone to false positives, keep severity low if relying only on this.
            severity = "Low"
            validatedData.reason = "Potential large distance movement detected (basic check)."
            validatedData.details.distance = distance
            validatedData.details.timeDiff = timeDiff
        end

        -- Experimental Raycasting Check (Guideline 31 Enhancement)
        local currentPos = validatedData.value or validatedData.details.currentPos -- Position reported by client/check
        local lastValidPos = session.metrics.lastValidPosition -- Last position deemed valid by server

        -- Ensure we have valid vector3 positions for raycasting.
        if type(currentPos) == "vector3" and type(lastValidPos) == "vector3" then
            local moveDistance = #(currentPos - lastValidPos)
            local noclipTolerance = Thresholds.noclipTolerance or 3.0 -- Configurable tolerance

            -- Define conditions for performing a raycast check:
            -- - Movement distance is significant (> tolerance).
            -- - Movement distance is not excessively large (to avoid checks on likely admin TPs/respawns).
            local maxSensibleDistance = (Thresholds.serverSideSpeedThreshold or 50.0) * 5.0 -- Heuristic: 5 seconds at max speed threshold
            if moveDistance > noclipTolerance and moveDistance < maxSensibleDistance then
                local sourcePed = GetPlayerPed(playerId)
                if sourcePed and sourcePed ~= -1 then
                    local ignoreEntity = sourcePed -- Ignore the player's own ped in the raycast.
                    local flags = 7 -- Intersect world geometry, objects, vehicles. Adjust as needed.
                    local zOffset = 0.5 -- Raycast slightly above ground level.

                    local rayStart = vector3(lastValidPos.x, lastValidPos.y, lastValidPos.z + zOffset)
                    local rayEnd = vector3(currentPos.x, currentPos.y, currentPos.z + zOffset)

                    -- WARNING: Synchronous raycasting with GetShapeTestResult immediately after StartShapeTestRay
                    -- is generally unreliable in FiveM due to its asynchronous nature.
                    -- A robust implementation requires handling the async result, potentially over multiple ticks.
                    -- This example uses a small wait, which is NOT a reliable solution.
                    local rayHandle = StartShapeTestRay(rayStart.x, rayStart.y, rayStart.z, rayEnd.x, rayEnd.y, rayEnd.z, flags, ignoreEntity, 7)
                    Citizen.Wait(50) -- !! Unreliable wait !! A proper async handler is needed.
                    local didHit, hitPosition, hitNormal, hitEntity = GetShapeTestResult(rayHandle)

                    if didHit then
                        -- Calculate distance from start to the hit point and total ray distance.
                        local distToHit = #(vector3(hitPosition.x, hitPosition.y, hitPosition.z) - rayStart)
                        local targetDist = #(rayEnd - rayStart)

                        -- If the hit occurred significantly *before* the destination (minus tolerance), flag as potential noclip.
                        if distToHit < (targetDist - noclipTolerance) then
                            isValid = true
                            severity = "High" -- Noclip/Teleport through objects is high severity.
                            validatedData.reason = string.format("Raycast detected potential noclip/teleport. Hit obstacle (Entity: %s) at [%.1f, %.1f, %.1f] while moving from [%.1f, %.1f, %.1f] to [%.1f, %.1f, %.1f].", tostring(hitEntity), hitPosition.x, hitPosition.y, hitPosition.z, lastValidPos.x, lastValidPos.y, lastValidPos.z, currentPos.x, currentPos.y, currentPos.z)
                            validatedData.details.raycastHit = true
                            validatedData.details.hitPos = hitPosition
                            validatedData.details.startPos = lastValidPos
                            validatedData.details.endPos = currentPos
                            validatedData.details.hitEntity = hitEntity
                            Log(("^1[NexusGuard Raycast] Noclip/Teleport detected for %s (ID: %d). Ray hit entity %s.^7"):format(playerName, playerId, tostring(hitEntity)), 1)
                        -- else -- Hit occurred close to destination, likely valid.
                        --    Log(("^3[NexusGuard Raycast] Raycast hit near destination for %s. Likely valid.^7"):format(playerName), 3)
                        end
                    -- else -- Raycast didn't hit anything.
                    --    Log(("^3[NexusGuard Raycast] Raycast path clear for %s.^7"):format(playerName), 3)
                    end
                end
            -- elseif moveDistance >= maxSensibleDistance then -- Log large movements but don't raycast.
            --     Log(("^3[NexusGuard Raycast] Skipping raycast for %s due to large distance (%.1fm). Likely admin TP or respawn.^7"):format(playerName, moveDistance), 3)
            end
        -- else -- Log if positions are invalid for raycasting.
        --    validatedData.reason = "Noclip/Teleport raycast validation requires valid current and last positions."
        end
        validatedData.serverValidated = isValid -- Update status based ONLY on the raycast result for now.

    -- Weapon Mod / Clip Size Check Validation
    elseif detectionType == "WeaponModification" or detectionType == "ServerWeaponClipCheck" then
        -- Extract data from the report (clip size, max allowed, weapon hash).
        local reportedClip = tonumber(validatedData.reportedClip) or tonumber(validatedData.details and validatedData.details.reportedClip)
        local maxAllowed = tonumber(validatedData.maxAllowed) or tonumber(validatedData.details and validatedData.details.maxAllowed)
        local weaponHash = validatedData.weaponHash or (validatedData.details and validatedData.details.weaponHash)

        -- Check if reported clip size exceeds the maximum allowed from config (Guideline 24).
        if reportedClip and maxAllowed and reportedClip > maxAllowed then
            isValid = true
            severity = "High" -- Modified weapon stats are high severity.
            validatedData.reason = string.format("Weapon %s clip size %d exceeded max allowed %d", weaponHash or 'Unknown', reportedClip, maxAllowed)
            validatedData.details.weapon = weaponHash
            validatedData.details.reported = reportedClip
            validatedData.details.allowed = maxAllowed
            validatedData.details.base = validatedData.baseClip or (validatedData.details and validatedData.details.baseClip)
        end
         validatedData.serverValidated = isValid

    -- Resource Mismatch Validation
    elseif detectionType == "ResourceMismatch" then
        -- This detection is generated server-side during the resource check, so it's inherently validated.
        isValid = true
        severity = "Critical" -- Resource tampering is critical severity.
        validatedData.reason = "Unauthorized client resources detected (" .. (validatedData.mode or validatedData.details.mode or "unknown mode") .. ")."
        validatedData.details.mismatched = validatedData.mismatched or validatedData.details.mismatched or {}
        validatedData.serverValidated = true -- Mark as server-validated.

    -- Menu Injection / Detection Validation
    elseif detectionType == "MenuInjection" or detectionType == "MenuDetection" then
         -- Server-side validation for menu injection is extremely difficult and unreliable.
         -- Primarily rely on client-side detection heuristics and resource verification.
         severity = "Critical" -- Assume high risk if client reports this.
         validatedData.reason = "Client reported potential menu keybinds or injection indicators."
         -- We cannot reliably validate this server-side based on the event alone.
         isValid = validatedData.clientValidated -- Trust the client's flag for now, but acknowledge lack of server validation.
         validatedData.serverValidated = false -- Explicitly mark as NOT server-validated.

    -- Handle Unknown Detection Types
    else
        Log(("^3Detections Validation Warning: Received unknown detection type '%s' from %s (ID: %d). Client validated: %s^7"):format(
            detectionType, playerName, playerId, tostring(validatedData.clientValidated)
        ), 2)
        severity = "Info" -- Treat unknown types as informational.
        validatedData.reason = "Unknown detection type received by server."
        isValid = validatedData.clientValidated -- Trust client flag if type is unknown.
        validatedData.serverValidated = false -- Cannot validate unknown types server-side.
    end

    -- 3. Apply Penalties if Server-Side Validation Confirmed the Detection
    if isValid then
        ApplyPenalty(playerId, session, detectionType, validatedData, severity)
    else
        -- Log instances where the client reported a detection, but server-side validation failed.
        -- This helps identify potential false positives from client detectors or areas needing better server validation.
        if validatedData.clientValidated then
             Log(("^2Detections Validation Info: Client flagged '%s' for %s (ID: %d), but server-side validation did not confirm. Reason: %s^7"):format(
                 detectionType, playerName, playerId, validatedData.reason or "Validation failed or insufficient data"
             ), 2)
             -- Optional: Apply a very minor trust penalty or log differently for unconfirmed client flags.
             -- ApplyPenalty(playerId, session, detectionType .. "_ClientOnly", validatedData, "Info")
        -- else -- Optional log for cases where neither client nor server validated (e.g., invalid data received)
             -- Log(("^3Detections Validation Info: Detection '%s' for %s (ID: %d) was not validated by client or server.^7"):format(detectionType, playerName, playerId), 3)
        end
    end

    -- Return the server-side validation status.
    return isValid
end

-- Export the Detections table.
return Detections
